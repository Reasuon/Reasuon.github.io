<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Reasuon</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://reasuon.github.io/"/>
  <updated>2020-02-19T03:24:13.290Z</updated>
  <id>http://reasuon.github.io/</id>
  
  <author>
    <name>Reasuon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java时间格式化工具SimpleDateFormat</title>
    <link href="http://reasuon.github.io/2020/02/19/Java%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7SimpleDateFormat/"/>
    <id>http://reasuon.github.io/2020/02/19/Java%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7SimpleDateFormat/</id>
    <published>2020-02-19T03:23:24.000Z</published>
    <updated>2020-02-19T03:24:13.290Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">└── java.text.Format</span><br><span class="line">   └── java.text.DateFormat</span><br><span class="line">      └── java.text.SimpleDateFormat</span><br></pre></td></tr></table></figure><p>SimpleDateFormat是格式和语言环境敏感的方式解析一个类的具体日期。可以格式化（日期→文本），分析（文本→日期），和归一化。</p><a id="more"></a><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormatTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实例化转换规则</span></span><br><span class="line">        <span class="comment">//常用格式</span></span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        <span class="comment">//Date格式的字符串转Date格式</span></span><br><span class="line">        SimpleDateFormat formatDate = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"EEE MMM d HH:mm:ss z yyyy"</span>,Locale.ENGLISH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Date转String  返回2018-4-3 16:42:23</span></span><br><span class="line">        String datetimeS = format.format(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Date格式的字符串转Date  返回Tue Apr 03 16:43:46 CST 2018</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date date = formatDate.parse((<span class="keyword">new</span> Date()).toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SimpleDateFormat参数"><a href="#SimpleDateFormat参数" class="headerlink" title="SimpleDateFormat参数"></a>SimpleDateFormat参数</h2><p>这里只介绍本文使用到的参数，其他参数请参照API文档<br>当在实例化规则时<br><code>SimpleDateFormat format = new SimpleDateFormat();</code><br><code>()</code>中的字符将被解释为规则，使用<code>&#39;</code>可以避免解释<br>例如<code>yyyy-MM-dd&#39;s</code>可以被解释为<code>年-月-日s</code>，即<code>2018-04-03s</code>，其中<code>s</code>不会被解释<br>解释参数如下:</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><p>不同参数不同数量有着不同的解释<br>如 <strong>M</strong> ，当只有一个或两个M参与解释时，将被解释为number类型，即四月的输出结果为 <strong>4</strong> 或 <strong>04</strong> (这里M的数量决定了 <strong>4</strong> 还是 <strong>04</strong> ，一个M对应 <strong>4</strong>，两个M在月份长度不超过两位时自动补全为两位)<br>M的数量超过两位时，就会被解释为Text类型，如 <strong>MMM</strong> 的四月的输出结果为 <strong>Apr</strong>(这里M的数量对应简写的长度)</p><p>各个参数更详细的对应关系请参考API文档</p><h2 id="Date格式"><a href="#Date格式" class="headerlink" title="Date格式"></a>Date格式</h2><p>Java中Date的格式默认为<code>星期简写 月份简写 日期 时间 时区缩写 年份</code>  </p><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><p>在阅读源码之前，可以先看看 <code>SimpleDateFormat</code> 的继承关系，如下:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">└── java.text.Format</span><br><span class="line">   └── java.text.DateFormat</span><br><span class="line">      └── java.text.SimpleDateFormat</span><br></pre></td></tr></table></figure><p>以下引用于 <code>java.text.Format</code></p><blockquote><h3 id="Subclassing"><a href="#Subclassing" class="headerlink" title="Subclassing"></a>Subclassing</h3><p>The Java Platform provides three specialized subclasses of Format– <code>DateFormat</code>, <code>MessageFormat</code>, and <code>NumberFormat</code>–for formatting dates, messages, and numbers, respectively.</p><p>Concrete subclasses must implement three methods:</p><ol><li><code>format(Object obj, StringBuffer toAppendTo, FieldPosition pos)</code></li><li><code>formatToCharacterIterator(Object obj)</code></li><li><code>parseObject(String source, ParsePosition pos)</code></li></ol></blockquote><p>上面那段的意思是 <code>java.text.Format</code> 就是官方提供了三个子类，分别格式化日期、数字、消息。而格式化日期的子类就是 <code>SimpleDateFormat</code> 的父类 <code>DateFormat</code>，主要提供字符串转日期类和日期类转字符串。<br>其中，三个子类都必须实现三个功能，分别是对象转字符串，生成中间对象 <code>AttributedCharacterIterator</code> (k-v 类型)，字符串转对象。<br>接下来看一下子类 <code>DateFormat</code> 是怎么继承这三个接口的。</p><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> StringBuffer <span class="title">format</span><span class="params">(Object obj, StringBuffer toAppendTo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     FieldPosition fieldPosition)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Date)</span><br><span class="line">        <span class="keyword">return</span> format( (Date)obj, toAppendTo, fieldPosition );</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Number)</span><br><span class="line">        <span class="keyword">return</span> format( <span class="keyword">new</span> Date(((Number)obj).longValue()),</span><br><span class="line">                      toAppendTo, fieldPosition );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot format given Object as a Date"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> StringBuffer <span class="title">format</span><span class="params">(Date date, StringBuffer toAppendTo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        FieldPosition fieldPosition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(date, <span class="keyword">new</span> StringBuffer(),</span><br><span class="line">                  DontCareFieldPosition.INSTANCE).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="parseObject"><a href="#parseObject" class="headerlink" title="parseObject"></a>parseObject</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">parseObject</span> <span class="params">(String source, ParsePosition pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parseObject</span><span class="params">(String source)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    ParsePosition pos = <span class="keyword">new</span> ParsePosition(<span class="number">0</span>);</span><br><span class="line">    Object result = parseObject(source, pos);</span><br><span class="line">    <span class="keyword">if</span> (pos.index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Format.parseObject(String) failed"</span>,</span><br><span class="line">            pos.errorIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight console&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.Object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── java.text.Format&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   └── java.text.DateFormat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      └── java.text.SimpleDateFormat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;SimpleDateFormat是格式和语言环境敏感的方式解析一个类的具体日期。可以格式化（日期→文本），分析（文本→日期），和归一化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://reasuon.github.io/tags/java/"/>
    
      <category term="SimpleDateFormat" scheme="http://reasuon.github.io/tags/SimpleDateFormat/"/>
    
      <category term="源码学习" scheme="http://reasuon.github.io/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 统一异常处理笔记</title>
    <link href="http://reasuon.github.io/2020/02/19/SpringBoot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>http://reasuon.github.io/2020/02/19/SpringBoot%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-19T01:03:21.000Z</published>
    <updated>2020-02-19T03:30:19.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法简介"><a href="#方法简介" class="headerlink" title="方法简介"></a>方法简介</h2><p>这里介绍三种方法对 <code>Spring Boot</code> 框架的web项目进行统一的异常捕获和处理，按照优先级排序如下(这个优先级不是真正的优先级，而是我为这四个方法处理异常定的优先级):</p><ol><li><code>@ExceptionHandler</code><ul><li>这个注解是在 <code>Spring 3.0</code> 中新增的注解，他可以用来处理局部的一部分异常，这个范围大致是抛出到该类里面的异常，在其它类以内被内消化的异常则不在此列。</li></ul></li><li><code>@ControllerAdvice</code><ul><li>这个注解是在 <code>Spring 3.2</code> 中新增的注解，它可以用于定义 <code>@ExceptionHandler</code> 、 <code>@InitBinder</code>、 <code>@ModelAttribute</code> ，并应用到所有 <code>@RequestMapping</code> 中。</li></ul></li><li><code>BasicErrorController</code><ul><li>直接在 <code>controller</code> 层继承该类，可以对指定的状态码的返回页面进行重定向或处理返回值信息，这种方式的优势在于可以处理为进入 <code>controller</code> 的请求，例如资源找不到 <code>404</code> ，参数错误的 <code>500</code> ，还可以对被过滤器过滤后的请求进行处理。</li></ul></li></ol><h2 id="局部异常的捕获与处理"><a href="#局部异常的捕获与处理" class="headerlink" title="局部异常的捕获与处理"></a>局部异常的捕获与处理</h2><p><code>@ExceptionHandler</code> 是用来处理局部变量的注解，该注解适合在定义完全局异常捕获之后，再对某部分特定的类再进行颗粒化的处理。<br>使用这个注解之后，异常会在抛出到该类之后被捕获并处理，如果不抛出到被 <code>@RequestMapping</code> 注解的<code>controller</code> 层接口，基本上就不会触发全局变量的捕获，所以可以做内消化。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>LocalController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 局部异常处理.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;对该文件内抛出的异常进行拦截并处理&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 包括其他文件抛到该文件内的异常，如service层&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> reasuon reasuon@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/local"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/error"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        String i = testService.getHandle();</span><br><span class="line">        map.put(<span class="string">"i"</span>, i);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部异常统一处理.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;只对当前Java文件内的方法有效，不过如果是server层或其他Java文件的异常抛出至这里，也生效&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 这种方式适合除了少且特殊的异常，如果是需要通用且大范围的异常处理，应该使用全局的方式来处理&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">exceptionHandle</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> NullPointerException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"空指针异常!&lt;--局部异常处理结果"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"异常类型未知!&lt;--局部异常处理结果"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种注解的方式，会将当前页面预备往外或往上抛出的异常集中捕获并处理，这样处理完之后，用户那倒的就不会是什么包什么类下的多少行往外抛出了一个空指针异常，而是收到我们处理之后的字符串。<br>未完待续…</p>]]></content>
    
    <summary type="html">
    
      Spring Boot 自带了十分强大且简单好用异常管理，只需要注解和几个类，数十行代码，就可以完成局部异常捕获，全局异常捕获，再配合 log4j2 甚至可以将异常进行定向输出
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="SpringBoot" scheme="http://reasuon.github.io/tags/SpringBoot/"/>
    
      <category term="异常" scheme="http://reasuon.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="笔记" scheme="http://reasuon.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>记一次因 IDEA 造成的 Git 切换分支自动恢复工作区的问题</title>
    <link href="http://reasuon.github.io/2020/02/18/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9B%A0IDEA%E9%80%A0%E6%88%90%E7%9A%84Git%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://reasuon.github.io/2020/02/18/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9B%A0IDEA%E9%80%A0%E6%88%90%E7%9A%84Git%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-18T06:14:26.000Z</published>
    <updated>2020-02-18T06:52:50.775Z</updated>
    
    <content type="html"><![CDATA[<p>今天突然发现，在 IDEA 上切换分支，竟然将上一个分支的内容同步到了新的分支，起初还以为切换分支失败了，结果 IDEA 提示分支切换成功，这就很奇怪了，理论上切换分支是不会将上一个分支没有 <code>commit</code> 的内容同步过来新分支的，因为这种操作会被 Git 阻止，就不应该切换成功，但是的确是切换成功了，修改也同步迁移到了新的分支，这使我十分混乱。<br>不过使用了这么久的 Git，也猜到了不是它的问题，这个问题不用想，可以肯定是出在 IDEA 上。</p><a id="more"></a><h2 id="测试触发手段"><a href="#测试触发手段" class="headerlink" title="测试触发手段"></a>测试触发手段</h2><ol><li>IDEA 内嵌的分支切换功能</li><li>Git 切换分支(IDEA 运行时)</li></ol><p>发现当上面两种方式，在还有修改没有提交时是可以切换分支的，并且可以将没有提交的修改同步到新的分支中。<br>这里已经可以完全肯定是 IDEA 的问题了，但是我没有想到，在 IDEA 运行期间，且项目目录和 Git 项目是同一个时，使用 Git 命令行的切换也是会触发。看来 IDEA 是监测了 Git 的行为，当需要切换分支时，保存当前修改到缓存，将工作区清理干净，所以 Git 可以切换成功，到时候 IDEA 再自动修改文件，基本就完成了整个过程。<br>脑补完整个过程，开始在 IDEA 里面寻找相关的设置，这个功能这么有趣，应该是可以设置开关状态的，果不其然，在版本管理的设置里面逛了好一会，发现了这个有趣的功能，因为以前没有在 idea 上进行“违规”的分支切换，所以一致不知道这个功能的存在。<br>这是一个叫做 <code>Restore workspace on branch switching</code> 的可勾选项，翻译过来大概意思就是“切换分支时自动恢复工作区”，这句话也不难理解，就是说将你在切换分支前，没有 <code>commit</code> 的修改内容同步到新的分支中，而在原生的 Git 里面，这种行为是不会被支持的。<br>当取消勾选，重启 IDEA 之后，再尝试未提交修改的前提下切换分支，果然被 IDEA 阻止，弹出提交窗口提示我提交代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天突然发现，在 IDEA 上切换分支，竟然将上一个分支的内容同步到了新的分支，起初还以为切换分支失败了，结果 IDEA 提示分支切换成功，这就很奇怪了，理论上切换分支是不会将上一个分支没有 &lt;code&gt;commit&lt;/code&gt; 的内容同步过来新分支的，因为这种操作会被 Git 阻止，就不应该切换成功，但是的确是切换成功了，修改也同步迁移到了新的分支，这使我十分混乱。&lt;br&gt;不过使用了这么久的 Git，也猜到了不是它的问题，这个问题不用想，可以肯定是出在 IDEA 上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://reasuon.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="问题解决" scheme="http://reasuon.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
      <category term="idea" scheme="http://reasuon.github.io/tags/idea/"/>
    
      <category term="git" scheme="http://reasuon.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Windows上配置gvim并作为C和C++的IDE</title>
    <link href="http://reasuon.github.io/2020/02/11/Windows%E4%B8%8A%E9%85%8D%E7%BD%AEGVim%E5%B9%B6%E4%BD%9C%E4%B8%BAC%E5%92%8CC++%E7%9A%84IDE/"/>
    <id>http://reasuon.github.io/2020/02/11/Windows%E4%B8%8A%E9%85%8D%E7%BD%AEGVim%E5%B9%B6%E4%BD%9C%E4%B8%BAC%E5%92%8CC++%E7%9A%84IDE/</id>
    <published>2020-02-11T03:30:28.000Z</published>
    <updated>2020-02-16T05:54:18.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在记录开始之前，我想先介绍一下vim和gvim。</p><blockquote><h2 id="vim和gvim"><a href="#vim和gvim" class="headerlink" title="vim和gvim"></a>vim和gvim</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Vim诞生的具体时间虽然没有具体的说明，但是最初创建它的原因据说是因为作者在新购入的计算机这当中并没有找到他熟悉的编辑器Vi，而Vim的诞生，起初是为了完全复制Vi的功能，但是在1992年1.22版本的Vim被移植到UNIX和MS-DOS上时开始，Vim的全名就改为Vi IMproved，此前，Vim的全名为Vi IMitation，也就是从这时起，Vim加入了不计其数的新功能。<br>&nbsp;&nbsp;&nbsp;&nbsp;Vim作为从Vi里面发展出来的类Vi中最优秀的一款编辑器，拥有代码补全、编译及错误跳转等方便编程的各类功能和插件，在程序员和文档编辑的工作人员中被广泛的使用着，同时也作为无GUI系统上最强的编辑器之一的存在（另一个为Emacs），Vim的操作完全可以不依赖于鼠标进行编辑，使用户的双手可以一直在打字区悬留，且各类插件强大功能的支撑下，Vim赢得了编辑器之神的美誉。<br>&nbsp;&nbsp;&nbsp;&nbsp;Vim虽然强大，但是从设计之初都只是为了在类UNIX的系统上运行，所以没有GUI也不兼容大多数有GUI的系统，为此，GVim诞生了，GVim拥有对用户较为友善的GUI，且在各大主流平台都有相应的安装包，将Vim完美的兼容到了各个主流平台，并且GUI也使得Vim的门槛也变得比较低，不再是曾经那个不看完说明书都不知道怎么保存退出的编辑器。  </p></blockquote><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>因为GVim和其插件以及MinGW对系统环境的要求并不严格，基本上都可以通过安装器直接安装并运行，所以这个环节没有任何内容，可以直接跳过。</p><h2 id="MinGW安装"><a href="#MinGW安装" class="headerlink" title="MinGW安装"></a>MinGW安装</h2><p>因为是作为C/C++的IDE，所以还需要在windows平台上安装C/C++的编译器，同样，在安装之前，先简单的介绍一下MinGW这个编译器。因为都是些老生常谈且比较浅显的东西，了解MinGW这个编译器的可以跳过介绍部分直接看安装。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;MinGW, a contraction of “Minimalist GNU for Windows”, is a minimalist development environment for native Microsoft Windows applications.<br>&nbsp;&nbsp;&nbsp;&nbsp;MinGW provides a complete Open Source programming tool set which is suitable for the development of native MS-Windows applications, and which do not depend on any 3rd-party C-Runtime DLLs. (It does depend on a number of DLLs provided by Microsoft themselves, as components of the operating system; most notable among these is MSVCRT.DLL, the Microsoft C runtime library. Additionally, threaded applications must ship with a freely distributable thread support DLL, provided as part of MinGW itself).<br>&nbsp;&nbsp;&nbsp;&nbsp;因为本人的英语水平所限，不对这部分进行翻译，大致意思就是MinGW是一个不依赖于外部C的类库，本身自带了所需的，系统没有的部分类库的一个极简的开发环境。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>下载<ul><li>曾经有一段时间MinGW的官网<a href="http://www.mingw.org/" target="_blank" rel="noopener" title="MinGW.org">http://www.mingw.org/</a>是无法在国内访问的，但是在我编撰这篇记录的时候，我又重新尝试访问了MinGW的官网，结果竟然成功了，在官网里面可以直接找到下载的地址，如果官网不能访问的话，也可以在其它地方进行下载，大部分时候下载到的都是安装器，自带更新检测，所以不用太担心下载不到最新的问题。</li></ul></li><li>安装MinGW<ul><li>最开始会选择安装的路径，后面所有下载到的资源文件都放在这个文件夹，所以尽量不要选择空间小的磁盘</li><li>在最开始会下载一些基本的信息，然后打开新的下载页面</li><li>选择需要安装的组件，我这里推荐无脑下载MinGW一开始推荐的列表上的所有组件，基本上后续的一些简单的开发都不会遇到编译上面的问题，后面再将需要的组件手动补齐即可，当然，熟悉的人自己选择所需的组件即可</li><li>等待下载，下载完即可使用</li></ul></li><li>配置环境变量<ul><li>新建新的系统变量<code>MINGW_HOME</code>存储MinGW的根目录，例如<code>D:\MinGW</code></li><li>在系统变量<code>Path</code>中添加<code>%MINGW_HOME%\bin</code></li></ul></li></ol><p>注意事项：<br>&nbsp;&nbsp;&nbsp;&nbsp;虽然不是每个人都会遇到下载失败的问题，但是还是要简单的提一下，因为目前下载器不能自己指定镜像，也不能设置代理，所以基本上是靠自己的网络状况来下载，不过部分可以全局代理的VPN是一个不错的选择，也可以在下载失败之后，记录下失败的文件，手动下载完之后放到自动创建的文件夹底下，下次启动下载器是会检查已下载的文件，存在则跳过下载环节，不过因为我是可以直接下载成功的(虽然下载失败了很多次，但是我重新下载了数次之后将失败的全部都下载下来了)，所以对于手动下载的具体操作我也说不好，大家可以自行百度。</p><h2 id="GVim安装"><a href="#GVim安装" class="headerlink" title="GVim安装"></a>GVim安装</h2><ol><li><p>下载</p><ul><li>GVim是不盈利的开源项目，在github上面搜索gvim就可以直接找到，不过我还是将可以发布页的链接贴出来，方便大家下载<a href="https://github.com/vim/vim-win32-installer/releases" target="_blank" rel="noopener" title="Release· vim/vim_win32_install· GitHub">https://github.com/vim/vim-win32-installer/releases</a></li></ul></li><li><p>解压</p></li><li><p>配置环境变量</p><ul><li>新建新的系统变量<code>VIM_HOME</code></li></ul><p>接下来就是重头戏了，Vim之所以强大是因为他的可扩展性十分强大，还拥有专门的脚本语言，极大的增强了插件的功能</p></li></ol><h2 id="GVim插件的安装"><a href="#GVim插件的安装" class="headerlink" title="GVim插件的安装"></a>GVim插件的安装</h2><p>在开始安装插件之前，我想先把我现在安装了的插件和其功能贴出来，方便大家参阅。</p><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;这里的功能不完全是插件的功能，而是我在配置我的gvim中所使用的插件的功能，还有许多重要的功能我并没有写出来，同样，等级也是对我自己的gvim来说的重要等级，每个人可以按照自己的需求和对插件的了解重新评估这个等级。</p></blockquote><ul><li><code>vundle</code><ul><li>功能：vundle是需要第一个安装的插件，虽然不是安装插件的必然插件，但是可以省下基本的查找、下载、安装的步骤，并且只需要知道名字或者github的链接就可以了。</li><li>等级：必要</li></ul></li><li><code>SuperTab</code><ul><li>功能：根据已存在的内容自动补全</li><li>等级：重要</li></ul></li><li><code>TagList</code><ul><li>功能：taglist是一个用于显示定位程序中各种符号的插件，例如宏定义、变量名、结构名、函数名这些东西 我们将其称之为符号(symbols)，而在taglist中将其称之为tag。显然，要想将程序文件中的tag显示出来，需要事先了解全部tag的信 息，并将其保存在一个文件中，然后去解析对应的tag文件。taglist做的仅仅是将tag文件中的内容解析完后显示在Vim上而已。</li><li>等级：必要</li></ul></li><li><code>NERDTree</code><ul><li>功能：NERDTree是一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录。</li><li>等级：必要</li></ul></li><li><code>WinManager</code><ul><li>功能：窗口管理，可以将TagList和NERDTree都控制在同一边并分上下屏，美观还省地方</li><li>等级：必要</li></ul></li><li><code>Vim-airline</code><ul><li>功能：这是一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件。</li><li>等级：重要</li></ul></li><li><code>OmniCppComplete</code><ul><li>功能：C/C++方法自动补齐，但是不打算把Vim当做一个C/C++开发的IDE的话不需要改插件</li><li>等级：非必要/必要</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;还有一个不能再Vundle里面安装的插件，ctags，推荐在github上面安装较新版本，ctags 5.8版本不能对更深的层级做递归，在生成Java源码和Java项目源码的tags时，只能生成一部分，需要注意一下</p><h3 id="Vundle安装"><a href="#Vundle安装" class="headerlink" title="Vundle安装"></a>Vundle安装</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Vundle是vim的插件管理器，只要安装完了Vundle，剩下的插件基本上就是一行命令的事情，所以，第一个安装的插件应该是Vundle（其实还有其他的插件管理器，不过我也没有用过，所以就不对其他的插件管理器做介绍了，有兴趣的可以自己百度），而Vundle插件的安装则依赖于Git和curl。</p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol><li>下载Git和Curl<ul><li>Git下载地址：<a href="https://github.com/git-for-windows/git/releases/" target="_blank" rel="noopener" title="git - Download">https://github.com/git-for-windows/git/releases/</a></li><li>Curl下载地址：<a href="https://curl.haxx.se/download.html" target="_blank" rel="noopener" title="curl - Download">https://curl.haxx.se/download.html</a>，需要注意的是，页面的最顶端的链接是源码的链接，下载前请看清楚。</li></ul></li><li>安装Git，将<code>Curl.exe</code>的位置加入系统变量<code>Path</code>中或者将<code>Curl.exe</code>放入<code>System32</code>下。</li><li>检测环境<ul><li>在控制台输入<code>git --version</code>和<code>curl --version</code>对两个工具进行检测，返回相应的版本信息则表示工具安装完成。</li></ul></li><li>安装Vundle<ul><li>在控制台中输入<code>$ git clone https://github.com/gmarik/vundle.git D:/vim/vim81/bundle/vundle</code>等待自动下载和安装</li></ul></li></ol><h3 id="Ctags"><a href="#Ctags" class="headerlink" title="Ctags"></a>Ctags</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>Ctags</code>绝对算得上一个重量级的插件，只要你想要把你的Vim打造成一个强大且适合你自己的IDE，毕竟他可以让你在各个方法和类当中随意跳转，无所拘束，但同时也是一个比较难控制的一个插件，关于这个插件的用法我几乎可以在写一篇，但那是另一篇了，这篇里面我就不多做赘述了。接下来简单讲一下<code>Ctags</code>的安装。</p><ol><li>下载<ul><li>在我写这篇文章的时候，百度出来的<code>Ctags</code>官网只能下载到5.8的版本，但是这个版本对层级比较深的源码，使用递归获取（指令<code>-R</code>）是拿不到的，所以要在<code>GitHub</code>上面下载更新的版本才能解决这个问题。</li><li>Github上Ctags的地址：<a href="https://github.com/universal-ctags/ctags-win32/releases" target="_blank" rel="noopener" title="github: ctags">https://github.com/universal-ctags/ctags-win32/releases</a></li></ul></li><li>解压</li><li>将<code>ctags.exe</code>所在的目录地址存入系统变量中</li></ol><h3 id="通过Vundle安装剩下的插件"><a href="#通过Vundle安装剩下的插件" class="headerlink" title="通过Vundle安装剩下的插件"></a>通过Vundle安装剩下的插件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;因为剩下的插件安装除了<code>ctags</code>基本上都可以通过Vundle安装，所以这里贴出我之前提到的插件的配置和安装指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Plugin Config Start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Ctags Config Start  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; 设置tags位置，这里要注意一点！+&#x3D; 两遍不能有空格！否则VIM无法解析！ &quot;</span><br><span class="line">&quot; C&#x2F;C++源码的tags &quot;</span><br><span class="line"> set tags+&#x3D;$TAGS\_HOME&#x2F;c\_cpp&#x2F;systags</span><br><span class="line">&quot; Java源码的tags</span><br><span class="line">&quot; set tags+&#x3D;$JAVA\_HOME&#x2F;src&#x2F;Java8Src</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Ctags Config End  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; TagList Config Start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; 指定taglist需要使用的ctags的地址，如果不指定该地址，taglist可能无法使用</span><br><span class="line">let Tlist\_Ctags\_Cmd &#x3D; &#39;D:\vim\ctags\ctags.exe&#39;</span><br><span class="line">&quot; taglist同时只展示1个文件的sysmbol列表，0 支持展示多个 &quot;</span><br><span class="line">let Tlist\_Show\_One\_File&#x3D;1</span><br><span class="line">&quot; 0的话就是显示在左边， 1 是右边 &quot;</span><br><span class="line">let Tlist\_Use\_Right\_Window&#x3D;0</span><br><span class="line">&quot; 当taglist是最后一个窗口时，自动退出Vim &quot;</span><br><span class="line">let Tlist\_Exit\_OnlyWindow&#x3D;1</span><br><span class="line">&quot; 实时更新tags &quot;</span><br><span class="line">let Tlist\_Process\_File\_Always&#x3D;1</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; TagList Config End &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; JavaComplete2 Config Start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">autocmd FileType java setlocal omnifunc&#x3D;javacomplete#Complete</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; JavaComplete2 Config End &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; WinManager Config Start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; 设置要管理的组件，并对NERDTree组件进行设置，如果不设置，则不能使用winManager启动NERDTree &quot;</span><br><span class="line">let g:NERDTree\_title&#x3D;&#39;NERD Tree&#39;</span><br><span class="line">let g:winManagerWindowLayout&#x3D;&#39;NERDTree|TagList&#39;</span><br><span class="line">function! NERDTree\_Start()</span><br><span class="line">    exec &#39;NERDTree&#39;</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">function! NERDTree\_IsValid()</span><br><span class="line">    return 1</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">&quot; 绑定F2到winmanager，并在启动时关闭额外自动打开的缓冲区 &quot;</span><br><span class="line">nmap \&lt;silent\&gt; \&lt;F2\&gt; :if IsWinManagerVisible() \&lt;BAR\&gt; WMToggle\&lt;CR\&gt; \&lt;BAR\&gt; else \&lt;BAR\&gt; WMToggle\&lt;CR\&gt;:q\&lt;CR\&gt; endif \&lt;CR\&gt;</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; WinManager Config End &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Plugin Config End &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Plugin Install Start &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line"></span><br><span class="line">&quot; 设置包括vundle和初始化相关的runtime path</span><br><span class="line">set rtp+&#x3D;$VIM\_HOME&#x2F;bundle&#x2F;Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; 让vundle管理插件版本,必须 &quot;</span><br><span class="line">Plugin &#39;VundleVim&#x2F;Vundle.vim&#39;</span><br><span class="line">&quot; 自动补全 &quot;</span><br><span class="line">Plugin &#39;SuperTab&#39;</span><br><span class="line">&quot; taglist是一个用于显示定位程序中各种符号的插件，例如宏定义、变量名、结构名、函数名这些东西 我们将其称之为符号(symbols)，而在taglist中将其称之为tag。显然，要想将程序文件中的tag显示出来，需要事先了解全部tag的信 息，并将其保存在一个文件中，然后去解析对应的tag文件。taglist做的仅仅是将tag文件中的内容解析完后显示在Vim上而已。 &quot;  </span><br><span class="line">Plugin &#39;taglist.vim&#39;</span><br><span class="line">&quot; NERDTree是一个用于浏览文件系统的树形资源管理外挂,它可以让你像使用Windows档案总管一样在VIM中浏览文件系统并且打开文件或目录。 &quot;  </span><br><span class="line">Plugin &#39;https:&#x2F;&#x2F;github.com&#x2F;scrooloose&#x2F;nerdtree.git&#39;</span><br><span class="line">&quot; 窗口管理 &quot;</span><br><span class="line">Plugin &#39;WinManager&#39;</span><br><span class="line">&quot; 这是一款状态栏增强插件，可以让你的Vim状态栏非常的美观，同时包括了buffer显示条扩展smart tab line以及集成了一些插件。 &quot;  </span><br><span class="line">Plugin &#39;Vim-airline&#39;</span><br><span class="line">&quot; C&#x2F;C++方法自动补齐 &quot;</span><br><span class="line">Plugin &#39;OmniCppComplete&#39;</span><br><span class="line">&quot; Java代码自动补全</span><br><span class="line">&quot; Plugin &#39;artur-shaik&#x2F;vim-javacomplete2&#39;</span><br><span class="line">&quot; 你的所有插件需要在下面这行之前，必须 &quot;</span><br><span class="line">call vundle#end()</span><br><span class="line">&quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本 &quot;</span><br><span class="line">filetype plugin indent on</span><br><span class="line">&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Plugin Install End &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br></pre></td></tr></table></figure><h3 id="vundle的基本命令"><a href="#vundle的基本命令" class="headerlink" title="vundle的基本命令"></a>vundle的基本命令</h3><p>在vim的命令行模式下，直接输入</p><ul><li><code>:PluginInstall</code> 安装插件</li><li><code>:PluginList</code> 查看已安装软件</li><li><code>:PluginClean</code> 清除列表中没有的插件</li><li><code>:h vundle</code> 查看帮助</li></ul><p>或者在控制台直接输入</p><ul><li><code>vim +PluginInstall +qall</code> 安装插件</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;以上就是搭建一个最最最基本的C/C++的IDE的基本教程，需要注意的是，我的配置文件里面也提到了Java代码自动补齐的插件，如果需要使用该插件，请确保自己的Vim支持Python（Python2或者Python3都可以），可以先在Vim的命令模式中输入<code>:python print(&quot;hello world&quot;)</code>，如果成功在输出的话，而不是提示缺少<code>pythonxx.dll</code>（<code>xx</code>指代数字，一般是版本号）的话，就是支持python且电脑已经安装了python环境，如果提示缺少dll，根据最后的数字下载安装就可以了，还有就是在控制台输入<code>vim --version</code>，如果是<code>+</code>号就代表支持，<code>-</code>号代表不支持，也就是说，<code>+python</code>/<code>+python/dyn</code>就是支持python2，<code>python3</code>/<code>python3/dyn</code>就是支持python3。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果出现不支持python环境的情况的话（虽然按照我的教程的地址下一般不会出现这个问题，但一定有些人已经有了自己的vim，所以还是要说一下），一般来说有两种办法，一个是重编译vim，使其支持python，好处是能够自己选择vim支持的python的版本，坏处就是windows上面基本没办法重编译，难度很高，另一个办法就简单点，重新下一个，反正vim最核心的还是配置文件和自己的脚本，迁移过来就好了，没有什么影响的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      Vim诞生的具体时间虽然没有具体的说明，但是最初创建它的原因据说是因为作者在新购入的计算机这当中并没有找到他熟悉的编辑器Vi，而Vim的诞生，起初是为了完全复制Vi的功能，但是在1992年1.22版本的Vim被移植到UNIX和MS-DOS上时开始，Vim的全名就改为Vi IMproved，此前，Vim的全名为Vi IMitation，也就是从这时起，Vim加入了不计其数的新功能。
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="工具" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="gvim" scheme="http://reasuon.github.io/tags/gvim/"/>
    
      <category term="c" scheme="http://reasuon.github.io/tags/c/"/>
    
      <category term="c++" scheme="http://reasuon.github.io/tags/c/"/>
    
      <category term="ide" scheme="http://reasuon.github.io/tags/ide/"/>
    
  </entry>
  
  <entry>
    <title>在 Github 上使用 Hexo 搭建简易个人博客</title>
    <link href="http://reasuon.github.io/2020/02/07/%E5%9C%A8Github%E4%B8%8A%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://reasuon.github.io/2020/02/07/%E5%9C%A8Github%E4%B8%8A%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-02-07T01:41:23.000Z</published>
    <updated>2020-02-16T05:55:56.126Z</updated>
    
    <content type="html"><![CDATA[<p><code>Github Page</code> 是 Github 官方提供的一种，用来方便搭建自己的静态页面博客的方法，它将免费赠送你一个 github.io 结尾的域名解析，这通常剩下三种做法:</p><ol><li>直接制作一个静态页面的个人博客并部署到 <code>http://username.github.io</code> 上</li><li>购买一个新的域名，并将其的解析指向 <code>http://username.github.io</code></li><li>制作一个动态页面，购买自己的云服务器，将动态页面的 API 接口指向云服务器，给予云服务器对该模块的 SSH 密钥，使用云服务器搭建博客后台，实现动态更新页面</li></ol><p>其中，难度最大的就是第3点，他要求你前后端以及服务器都得熟悉，我虽然很熟悉后端和服务器，但对于前端可以说是一窍不通，所以这里我选择用第1点，借助工具制作一个静态页面，并部署到自己的 github.io 上</p><a id="more"></a><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>Github 账号</li><li>git</li><li>npm</li><li>hexo</li></ul><h2 id="搭建-github-io-项目"><a href="#搭建-github-io-项目" class="headerlink" title="搭建 github.io 项目"></a>搭建 <code>github.io</code> 项目</h2><p>首先，你得先在 Github 上搭建一个 Github Page，这个过程也十分的简单，直接创建一个名称为你用户名，后缀为 <code>github.io</code> 的仓库，如下:<br><img src="https://raw.githubusercontent.com/Reasuon/picBlog/master/Snipaste_2020-02-07_14-05-48.jpg" alt="创建项目"><br>这里需要注意的是，<code>github.io</code> 前的这个单词，必须要和用户名一致，且不能再次分级，例如我这里就是 <code>Reasuon.github.io</code>，它不能是 <code>Reasuonnnnn.github.io</code>，也不能是 <code>R.Reasuon.github.io</code>，原因虽然不明，不过这些注意事项在 Github 官方介绍 Github Page 的注意事项里面有，有兴趣的可以直接根据官方网站搭建，这里留个链接方便跳转:<a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a><br>创建完之后会是一个提示如何初始化该仓库的页面，无需管他，只需要复制 ssh 的 git 链接即可，格式: <code>git@github.com:username/username.github.io.git</code>，这里将 <code>username</code> 改为你的用户名，也可以直接套用上去，将他先保存在一个文本里面，等一下 hexo 的博客部署地址要用到它</p><h2 id="初始化个人博客"><a href="#初始化个人博客" class="headerlink" title="初始化个人博客"></a>初始化个人博客</h2><p>这里因为我的环境是 Windows 10，所以直接使用 cmd 作为展示，当安装完之后，打开 cmd 窗口</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>因为 hexo 下载主题和将项目上传到 Gtihub 都需要 Git，所以必须要先安装一个 Git<br>前往 Git 的官网 <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a> 直接下载对应的安装包安装即可。  </p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Reasuon</span>&gt;<span class="title">git</span> --<span class="title">version</span></span></span><br><span class="line"><span class="function"><span class="title">git</span> <span class="title">version</span> 2.18.0.<span class="title">windows</span>.1</span></span><br></pre></td></tr></table></figure><p>这里返回了 2.18.0.windows.1 的版本信息<br>然后就是配置 Git 的使用者信息，命令如下:  </p><h4 id="配置用户名"><a href="#配置用户名" class="headerlink" title="配置用户名"></a>配置用户名</h4><p>将 username 改为你的用户名即可，这里只是为了方便辨识，所以用户名要求并不严谨，可以任意起<br><code>git config --global user.name username</code></p><h4 id="配置邮箱"><a href="#配置邮箱" class="headerlink" title="配置邮箱"></a>配置邮箱</h4><p>这里也是将 <a href="mailto:xxxx@xxx.com">xxxx@xxx.com</a> 修改为你自己的邮箱即可，并不需要和 github 对应<br><code>git config --global user.email xxxx@xxx.com</code></p><h4 id="创建公密钥"><a href="#创建公密钥" class="headerlink" title="创建公密钥"></a>创建公密钥</h4><p><code>ssh-keygen</code><br>输入指令之后，它会要求你输入密码和选择保存位置，这里为了方便直接回车跳过，这样使用 Git 的时候就不需要密码，只要密钥不泄露就很安全，而默认的保存位置在 <code>~/.ssh</code> 下，Windows 就是 <code>C:\User\username\.ssh\</code> 下</p><h4 id="Github-绑定"><a href="#Github-绑定" class="headerlink" title="Github 绑定"></a>Github 绑定</h4><p>进入 Github 的个人设置中，点击左侧的 <code>SSH and GPG keys</code>，然后新增 <code>SSH key</code>，将 git 生成 <code>id_rsa.pub</code> 的内容复制进 key 框中，起个 title 保存即可。</p><h3 id="安装-npm"><a href="#安装-npm" class="headerlink" title="安装 npm"></a>安装 npm</h3><p>前往 nodejs 的官网 <a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a> 下载对应平台的安装包，直接安装即可  </p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">Reasuon</span>&gt;<span class="title">npm</span> -<span class="title">v</span></span></span><br><span class="line"><span class="function">6.4.1</span></span><br></pre></td></tr></table></figure><p>这里返回了 <code>6.4.1</code> 的版本号信息，基本可以确认安装完成了，这时候就可以开始安装 hexo，当然，在安装这些第三方的工具之前可以将安装位置也指定好，不然好像会直接装到 C 盘中，当然，如果对 C 盘的容量不太敏感，也可以不做，这里我就略过了，感兴趣的可以百度一下，有详细的过程<br>安装过程(指令在 cmd 内输入):  </p><p>安装 cnpm，防止因为网络问题下载后续的包下载失败  </p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><h4 id="Hexo-介绍"><a href="#Hexo-介绍" class="headerlink" title="Hexo 介绍"></a>Hexo 介绍</h4><p>官网首页是如下介绍它的:</p><blockquote><p>A fast, simple &amp; powerful blog framework</p></blockquote><p>官方的文档也做过比较详细的说明:</p><blockquote><p>Hexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other markup languages) and Hexo generates static files with a beautiful theme in seconds.</p></blockquote><p>总的来说，Hexo 就是一个简单的将你的 markdown 文件处理成漂亮的静态页面文件的一个框架，这个框架上搭载了许多的功能，你能将这个页面文件都用 Hexo 自带的服务管理起来，并提供一些自带或第三方的功能，例如检索、部署到远程服务器等功能。<br>那就是说，这个 Hexo，它是一个框架，我们需要一个工具用来启动和管理它，那就是官方提供的 Hexo-cli，用这个工具和下载下来的 Hexo 框架，经过我们的自定义后生成一堆静态文件，然后将这堆东西部署到远程服务器上面。</p><h4 id="安装-hexo-cli"><a href="#安装-hexo-cli" class="headerlink" title="安装 hexo-cli"></a>安装 hexo-cli</h4><p>使用命令 <code>cnpm install hexo-cli -g</code> 来安装 hexo-cli<br>使用命令 <code>hexo v</code> 查看 hexo-cli 的版本号，只要能输出版本信息就代表安装完成</p><h4 id="初始化个人博客项目"><a href="#初始化个人博客项目" class="headerlink" title="初始化个人博客项目"></a>初始化个人博客项目</h4><p>首先需要创建一个文件夹用来存放项目文件，文件夹名称可以随便取，无硬性要求，这里我创建了一个 HexoBlog 的文件夹用来存放项目文件。<br>在该文件夹中打开 cmd，输入 <code>hexo init</code>，他就会自己开始创建一个新的项目在当前文件夹下，等待项目初始化结束之后，可以先打开项目尝试是否能够成功，一般来说输出以下内容就是没有任何问题了:</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E:\<span class="title">HexoBlog</span>&gt; <span class="title">hexo</span> <span class="title">s</span></span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Start</span> <span class="title">processing</span></span></span><br><span class="line"><span class="function"><span class="title">INFO</span>  <span class="title">Hexo</span> <span class="title">is</span> <span class="title">running</span> <span class="title">at</span> <span class="title">http</span>://<span class="title">localhost</span>:4000 . <span class="title">Press</span> <span class="title">Ctrl</span>+<span class="title">C</span> <span class="title">to</span> <span class="title">stop</span>.</span></span><br></pre></td></tr></table></figure><p>当成功启动时，先输出两行 INFO，提示已启动，再提示启动成功后的地址，在浏览器输入 <code>http://localhost:4000</code> 即可访问 hexo 自带的一个模板。<br><em>如果访问失败，有可能时 <code>localhost</code> 没有映射为 <code>127.0.0.1</code> 的原因，可以尝试用 <code>http://127.0.0.1:4000</code> 访问</em></p><h4 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h4><p>当确认可以正常启动，页面也能看到一个初始的模板的时候，就可以开始配置这个项目了。<br>配置主要分为底下几个部分:</p><ol><li>项目全局配置<ul><li>语言(这里的配置主要是看主题是否支持)</li><li>Title</li><li>Github 仓库地址</li></ul></li><li>主题<ul><li>下载主题</li><li>主题配置</li></ul></li></ol><h5 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h5><p>打开现在位于根目录下的配置文件 <code>_config.yml</code>，这个是当前项目的配置，修改一下几个部分即可</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Reasuon</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p><code>title</code> 是浏览器打开该项目时，处于标签栏的名称，<code>language</code> 则是使用的语言，如果需要使用主题，则需要知道对方主题是否提供了该语言。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>这个是你的 github 仓库的配置，如果是和当前教程一样使用的 github 作为仓库的话，可以直接参考我下面这个模板</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:Reasuon/Reasuon.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p><code>repo</code> 改为你的 github 仓库的 ssh 的地址，文章 <code>1.</code> 节应该已经让你保存起来了，如果没有的话重新访问 github 上的项目，复制一下即可。<code>branch</code> 对应的是项目的分支，如果对 git 的分支不够了解的话，这个选项填 <code>master</code> 就可以了，基本上 <code>Github Page</code> 用不上其他分支。<br>如果是采用了其它东西作为项目仓库的，可以参考一下注释中提到的地址: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></p><h5 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h5><p>首先需要先选择一个自己喜欢的主题，虽然随时都可以替换，不过到时候可能配置和功能可能会有所不同，所以一开始最好先选一个喜欢的，以后更换的次数少，踩得坑也会少点点。<br><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 是官方提供的主题展示页面，里面包含了大部分的主题，你可以直接在里面挑一个喜欢的，点进去里面，大部分都附上了主题的安装教程，如果没有，可以在 Github 上搜索该主题，在 Github 上，一般会有相关的安装教程，实在还没有可以看看 Issues 里面提问，或是尝试直接安装。<br>以下附上我安装主题的过程记录，以便参考</p><p>主题: <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">https://github.com/tufu9441/maupassant-hexo</a></p><p>首先在项目根目录输入以下指令:</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">cnpm install hexo-renderer-pug --save</span><br><span class="line">cnpm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure><p>教程上虽然是使用 npm 来下载，但是在下载 <code>hexo-renderer-sass</code> 的时候又很大的概率下载失败，这里使用的是教程推荐的淘宝镜像源 cnpm</p><p>修改启用的主题:<br>打开根目录的 <code>_config.yml</code>，找到 <code>theme:</code> 这一栏，将值改为 <code>themes</code> 文件夹下的对应主题文件夹名称，上面下载的指令将主题文件夹命名为 <code>maupassant</code>，所以这一栏改为 <code>themes: maupassant</code> 即可。<br>重启项目就完成了主题的替换。<br>根据指令 <code>hexo s</code> 重启项目，确认替换无误。如果出现替换之后无反应，尝试使用 <code>hexo g</code> 重新生成页面文件</p><h4 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h4><p>因为这个是发布静态页面文件到 Github Page 上，所以我们并不是直接将当前项目上传到 Github Page 上，而是通过 hexo 自带的命令生成静态页面文件并自动上传到 Github Page 上，但是如果想直接上传到 Github Page，还有以下三个点要注意下:</p><ol><li><input checked="" disabled="" type="checkbox"> Github Page 仓库</li><li><input checked="" disabled="" type="checkbox"> 在配置文件配置 Github Page 仓库地址</li><li><input disabled="" type="checkbox"> Hexo 上传到 Github 的 module</li></ol><p>1、2 两步都已经在上面解决了，现在还需要安装一个扩展 <code>hexo-deployer-git</code>，指令为: <code>cnpm install hexo-deployer-git --save</code><br>现在就可以直接上传到 Github 上，指令为: <code>hexo d</code>，或者在部署前自动更新的指令: <code>hexo d -g</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Github Page&lt;/code&gt; 是 Github 官方提供的一种，用来方便搭建自己的静态页面博客的方法，它将免费赠送你一个 github.io 结尾的域名解析，这通常剩下三种做法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接制作一个静态页面的个人博客并部署到 &lt;code&gt;http://username.github.io&lt;/code&gt; 上&lt;/li&gt;
&lt;li&gt;购买一个新的域名，并将其的解析指向 &lt;code&gt;http://username.github.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;制作一个动态页面，购买自己的云服务器，将动态页面的 API 接口指向云服务器，给予云服务器对该模块的 SSH 密钥，使用云服务器搭建博客后台，实现动态更新页面&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，难度最大的就是第3点，他要求你前后端以及服务器都得熟悉，我虽然很熟悉后端和服务器，但对于前端可以说是一窍不通，所以这里我选择用第1点，借助工具制作一个静态页面，并部署到自己的 github.io 上&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人博客" scheme="http://reasuon.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="markdown" scheme="http://reasuon.github.io/tags/markdown/"/>
    
      <category term="github page" scheme="http://reasuon.github.io/tags/github-page/"/>
    
      <category term="hexo" scheme="http://reasuon.github.io/tags/hexo/"/>
    
      <category term="个人博客" scheme="http://reasuon.github.io/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="静态页面" scheme="http://reasuon.github.io/tags/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java 字符集的坑</title>
    <link href="http://reasuon.github.io/2019/12/18/Java%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E5%9D%91/"/>
    <id>http://reasuon.github.io/2019/12/18/Java%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E5%9D%91/</id>
    <published>2019-12-17T23:40:55.000Z</published>
    <updated>2020-02-17T09:27:37.592Z</updated>
    
    <content type="html"><![CDATA[<p>在 Linux 运行了 Windows 上写的程序，出现了 Windows 平台没有出现的乱码问题，这里记录一下解决的想法与过程</p><a id="more"></a><h2 id="1-字符集转换前后都乱码"><a href="#1-字符集转换前后都乱码" class="headerlink" title="1. 字符集转换前后都乱码"></a>1. 字符集转换前后都乱码</h2><blockquote><p>注: 以下环境和输出都是 utf-8</p></blockquote><p>总结: Java 在获取当前系统的文件夹下所有文件时是依赖与系统实现的。</p><p>坑: 目标服务器是 <code>zh_CN.UTF-8</code>，而设备通过 <code>FTP</code> 上传到服务器的文件名的字符集是 <code>GBK</code>，这就意味在获取文件名的时候需要注意对文件名进行转码，这看似简单的一步缺暗藏两个玄机。  </p><h3 id="1-1-字符集转换不可逆"><a href="#1-1-字符集转换不可逆" class="headerlink" title="1-1. 字符集转换不可逆"></a>1-1. 字符集转换不可逆</h3><blockquote><p>注: 并非所有字符集的转换都不可逆</p></blockquote><p>首先是第一个小坑，字符集的转换，特别是 <code>GBK</code> 和 <code>UTF-8</code> 的转换，因为他们两个对每个字的字节长度定义不同，一个是两字节的定长长度，一个是一到三字节的不定长长度(汉字一般是三字节)，这就使得只有正确的解析才能将两个字符集之间的内容进行转换，一旦错误的解析(例如对字符集为 UTF-8 的内容用字符集 gbk 来进行解析，就基本上回不去了)<br>这个坑在理解字符集转换的原理之前可能会感到很费解，例如一开始我就知道目标文件的字符集是 GBK，所以当我发现我用 UTF-8 启动的项目拿到文件名就已经是乱码的时候，是意料之中，所以我对它进行了从 GBK 转 UTF-8 的操作，结果是乱码，仔细对比转换之前的输出发现并不是 GBK(输出到日志并用 GBK 对文件名进行解析，发现还是失败)，这时候我突然发现我拿到的文件名是 GBK 用 UTF-8 的编码格式转换出来的文件名。就好比在我拿到这个文件名之前，有人对它进行了如下操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是我以为我能拿到的，GBK 的文件名</span></span><br><span class="line">        String fileNameGBK = <span class="keyword">new</span> String(<span class="string">"文件名"</span>.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">// 结果我拿到的是 GBK 被强行用 UTF-8 解析后的结果</span></span><br><span class="line">        String resultFileName = <span class="keyword">new</span> String(fileNameGBK.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        System.out.println(<span class="string">"GBK:"</span> + fileNameGBK);</span><br><span class="line">        System.out.println(<span class="string">"用UTF-8解析后GBK后的UTF-8:"</span> + resultFileName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GBK: 鏂囦欢鍚�</span><br><span class="line">用UTF-8解析后GBK后的UTF-8: 閺傚洣娆㈤崥锟�</span><br></pre></td></tr></table></figure><p>当我发现到手的字符集是被处理过的时候，我马上就开始了反向转换，而这时候，我压根就没想到还有数据丢失，大致的流程如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是我以为我能拿到的，GBK 的文件名</span></span><br><span class="line">        String fileNameGBK = <span class="keyword">new</span> String(<span class="string">"文件名"</span>.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">// 结果我拿到的是 GBK 被强行用 UTF-8 解析后的结果</span></span><br><span class="line">        String resultFileName = <span class="keyword">new</span> String(fileNameGBK.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        System.out.println(<span class="string">"GBK: "</span> + fileNameGBK);</span><br><span class="line">        System.out.println(<span class="string">"用UTF-8解析后GBK后的UTF-8: "</span> + resultFileName);</span><br><span class="line">        <span class="comment">// 反向转换</span></span><br><span class="line">        String gbkTo = <span class="keyword">new</span> String(resultFileName.getBytes(<span class="string">"GBK"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 将反向转换后的结果用 gbk 解析转成 utf-8</span></span><br><span class="line">        String utfTo = <span class="keyword">new</span> String(gbkTo.getBytes(<span class="string">"GBK"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"逆向转换: "</span> + gbkTo);</span><br><span class="line">        System.out.println(<span class="string">"正确解析: "</span> + utfTo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GBK: 鏂囦欢鍚�</span><br><span class="line">用UTF-8解析后GBK后的UTF-8: 閺傚洣娆㈤崥锟�</span><br><span class="line">逆向转换: 鏂囦欢鍚�?</span><br><span class="line">正确解析: 文件�??</span><br></pre></td></tr></table></figure><p>这里我们可以看到，当进行逆向的转换时，乱码后面出现了一个?号，然后再解析成 utf-8 的时候，不可避免的丢失了最后一个字符，但是这不是绝对的，如果我们把一开始的 <code>文件名</code> 改为 <code>文1件2名3</code>，这时候就是毁灭性的了，这个时候的输出结果如下:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GBK: 鏂�1浠�2鍚�3</span><br><span class="line">用UTF-8解析后GBK后的UTF-8: 閺傦拷1娴狅拷2閸氾拷3</span><br><span class="line">逆向转换: 鏂�1浠�2鍚�3</span><br><span class="line">正确解析: �?1�?2�?3</span><br></pre></td></tr></table></figure><p>可以看到的是，当之后中文的时候，只是丢失了最后一个汉字，但是当这段汉字里面夹杂着数字或者字母的时候，毁灭性的一幕就出现了，全部汉字都变成了乱码，真的没救了。<br>当然，造成这种结果的原因很简单，就在于 GBK 和 UTF-8 的编码格式不一样<br>GBK 是定长的两字节长度，而 UTF-8 为了节省空间，是不定长的，数字和字母只需要一个字节长度就能装下，但是汉字需要三个字节长度，所以当一个汉字和一个数字一前一后放在一起的时候，GBK 第四个字节的内容里面放的是数字和字母，前面使用一个固定的内容作为标识，所以 utf-8 在解析第四个字节的时候能够成功解析为数字，但是前三个字节就会被解析成两个乱码。并且因为汉字的值在 GBK 里面也是比较大， utf-8 需要把自己扩充为三个字节的长度来适应汉字，所以整个的内容就全变了。<br>我们不妨把从前到后的四个字段都转成 byte 数组，那么就会明显上很多<br>我们先转换最初的两个，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是我以为我能拿到的，GBK 的文件名</span></span><br><span class="line">        String fileNameGBK = <span class="keyword">new</span> String(<span class="string">"文1件2名3"</span>.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">// 结果我拿到的是 GBK 被强行用 UTF-8 解析后的结果</span></span><br><span class="line">        String resultFileName = <span class="keyword">new</span> String(fileNameGBK.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        System.out.println(<span class="string">"GBK:"</span> + fileNameGBK);</span><br><span class="line">        System.out.println(<span class="string">"用UTF-8解析后GBK后的UTF-8:"</span> + resultFileName);</span><br><span class="line">        <span class="keyword">byte</span>[] fileNameGBKBytes = fileNameGBK.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] resultFileNameBytes = resultFileName.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> b : fileNameGBKBytes) &#123;</span><br><span class="line">            System.out.print(<span class="string">"| "</span> + b + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"|"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : resultFileNameBytes) &#123;</span><br><span class="line">            System.out.print(<span class="string">"| "</span> + b + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"|"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GBK: 鏂�1浠�1鍚�1</span><br><span class="line">用UTF-8解析后GBK后的UTF-8: 閺傦拷1娴狅拷1閸氾拷1</span><br><span class="line">| -26 | -106 | 63 | 49 | -28 | -69 | 63 | 50 | -27 | -112 | 63 | 51 |</span><br><span class="line">| -23 | -113 | -126 | -17 | -65 | -67 | 49 | -26 | -75 | -96 | -17 | -65 | -67 | 50 | -23 | -115 | -102 | -17 | -65 | -67 | 51 |</span><br></pre></td></tr></table></figure><p>这里虽然 GBK 的输出看起来是有9个字，但是这个控制台也是 utf-8，所以这个乱码是已经没救的乱码<br>通过观察第一行 byte[] 可知 gbk 的三个字的确是六个字节的长度，并且可以发现，63|49 和 63|50 和 63|51 分别代表了1、2、3<br>而第二行长达21个字节长度的乱码，其实用 gbk 已经无法解析了，但是用 utf-8 却可以解析，除了单个字节就能代表的49、50、51分别指代了1、2、3，其他在utf-8里面都是三个字节作为一个乱码存在，所以这里应该是18个字节的汉字，共六个，三个字节的数字，共三个，一共9个字，刚好和 gbk 输出在控制台的乱码一样。<br>所以我们可以发现这时候如果想转回去，凭空多出来三个字，并且这三个字都是 -17|-65|-67 ，也都恰好在数字的前面。<br>所以基本上这三个汉字都已经救不回来了。<br>这里把恢复的过程也放出来，这样就简单明了多了，不过还是要懂得字符集相关的知识理解起来会快上很多。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个是我以为我能拿到的，GBK 的文件名</span></span><br><span class="line">        String fileNameGBK = <span class="keyword">new</span> String(<span class="string">"文1件2名3"</span>.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">// 结果我拿到的是 GBK 被强行用 UTF-8 解析后的结果</span></span><br><span class="line">        String resultFileName = <span class="keyword">new</span> String(fileNameGBK.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        System.out.println(<span class="string">"GBK: "</span> + fileNameGBK);</span><br><span class="line">        System.out.println(<span class="string">"用UTF-8解析后GBK后的UTF-8: "</span> + resultFileName);</span><br><span class="line">        <span class="comment">// 反向转换</span></span><br><span class="line">        String gbkTo = <span class="keyword">new</span> String(resultFileName.getBytes(<span class="string">"GBK"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 将反向转换后的结果用 gbk 解析转成 utf-8</span></span><br><span class="line">        String utfTo = <span class="keyword">new</span> String(gbkTo.getBytes(<span class="string">"GBK"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"逆向转换: "</span> + gbkTo);</span><br><span class="line">        System.out.println(<span class="string">"正确解析: "</span> + utfTo);</span><br><span class="line">        <span class="keyword">byte</span>[] fileNameGBKBytes = fileNameGBK.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] resultFileNameBytes = resultFileName.getBytes(<span class="string">"GBK"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] gbkToBytes = gbkTo.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] utfToBytes = utfTo.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> b : fileNameGBKBytes) &#123;</span><br><span class="line">            System.out.print(<span class="string">"| "</span> + b + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"|"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : resultFileNameBytes) &#123;</span><br><span class="line">            System.out.print(<span class="string">"| "</span> + b + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"|"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : gbkToBytes) &#123;</span><br><span class="line">            System.out.print(<span class="string">"| "</span> + b + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"|"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : utfToBytes) &#123;</span><br><span class="line">            System.out.print(<span class="string">"| "</span> + b + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"|"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GBK: 鏂�1浠�2鍚�3</span><br><span class="line">用UTF-8解析后GBK后的UTF-8: 閺傦拷1娴狅拷2閸氾拷3</span><br><span class="line">逆向转换: 鏂�1浠�2鍚�3</span><br><span class="line">正确解析: �?1�?2�?3</span><br><span class="line">| -26 | -106 | 63 | 49 | -28 | -69 | 63 | 50 | -27 | -112 | 63 | 51 |</span><br><span class="line">| -23 | -113 | -126 | -17 | -65 | -67 | 49 | -26 | -75 | -96 | -17 | -65 | -67 | 50 | -23 | -115 | -102 | -17 | -65 | -67 | 51 |</span><br><span class="line">| -23 | -113 | -126 | -17 | -65 | -67 | 49 | -26 | -75 | -96 | -17 | -65 | -67 | 50 | -23 | -115 | -102 | -17 | -65 | -67 | 51 |</span><br><span class="line">| -17 | -65 | -67 | 63 | 49 | -17 | -65 | -67 | 63 | 50 | -17 | -65 | -67 | 63 | 51 |</span><br></pre></td></tr></table></figure><p>可以看到在最后的时候，出现了一模一样的乱码，这种情况是因为 utf-8 里面的乱码在 gbk 里面并没有对应的，所以出现了这个乱码，所以我们基本上可以确定的是，一旦第一步错了，后面就基本没办法修复数据了。<br>所以在拿到数据发现不是 GBK 的时候，应该反应过来不要尝试反向出来，应该想办法解决拿到就是被处理过的数据的这个问题。</p><h3 id="1-2-系统提供的文件信息"><a href="#1-2-系统提供的文件信息" class="headerlink" title="1-2. 系统提供的文件信息"></a>1-2. 系统提供的文件信息</h3><p>我最开始是使用 Java 原生提供的获取文件目录的方法 <code>java.io.File.getFiles()</code>，它返回了一个文件数组，但是，这个时候的文件名已经是不可修复的乱码了，所以我们得解决这个问题。<br>首先我们得知道为什么拿到手的数据就已经是乱码了<br>这个是因为 Java 获取文件目录并不是虚拟机 jvm 去读取的，所以不管你怎么修改项目的默认字符集，jvm启动时指定任何的字符集，在获取文件列表这个行为上，是 jvm 访问系统，拿到系统返回的数组，这应该是用 Java 自带的 dll 或者是 so 提供的功能，而他们统一使用当前系统的字符集<br>所以这个时候应该修改当前系统的字符集，这里我是用的是 CentOS7，所以只需要修改 <code>/etc/locale.conf</code>，将 <code>LANG</code> 这一项改为 <code>zh_SG.gbk</code>就行了，大致内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#LANG&#x3D;&quot;zh_CN.utf-8&quot;</span><br><span class="line">LANG&#x3D;&quot;zh_SG.gbk&quot;</span><br></pre></td></tr></table></figure><p>再 souce 一下配置文件就可以立即生效了，未生效也可以先退出 ssh 重新登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/locale.conf</span><br></pre></td></tr></table></figure><p>当然，最好先使用 <code>locale -a</code> 查看一下当前系统支持的语言，不支持可以先安装后修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Linux 运行了 Windows 上写的程序，出现了 Windows 平台没有出现的乱码问题，这里记录一下解决的想法与过程&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="问题解决" scheme="http://reasuon.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Java" scheme="http://reasuon.github.io/tags/Java/"/>
    
      <category term="字符集" scheme="http://reasuon.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>记一次使用 esxi 备份虚拟机</title>
    <link href="http://reasuon.github.io/2019/08/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8esxi%E5%A4%87%E4%BB%BD%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://reasuon.github.io/2019/08/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8esxi%E5%A4%87%E4%BB%BD%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2019-08-17T06:51:03.000Z</published>
    <updated>2020-02-17T09:30:15.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><h3 id="1-缺少磁盘映像1"><a href="#1-缺少磁盘映像1" class="headerlink" title="1. 缺少磁盘映像1"></a>1. 缺少磁盘映像1</h3><p>事情的经过是这样的，我在一次出差时，厂家突然要收回借给我们的用来搭建测试环境的硬盘，无奈之下我只能将虚拟机转移到其他服务器上面，但是却遇到了一个极其操蛋的问题，那就生成的 <code>.ovf</code> 模板文件在导入到另一台服务器的时候报错了，提示缺少磁盘映像文件，我百度了一下，网上大部分的文章都是说缺少文件，但是并没有说缺的是什么文件，终于有个人突然提到是因为原虚拟机是由 iso 的，但是新的服务器上面并没有这个镜像，于是就报错了。</p><p>解决方法:</p><p>重新创建一个 <code>.ovf</code> 模板文件，但是在创建之前，先编辑虚拟机，直接将光盘×掉，防止读取镜像文件。</p><a id="more"></a><h3 id="2-缺少磁盘映像2"><a href="#2-缺少磁盘映像2" class="headerlink" title="2. 缺少磁盘映像2"></a>2. 缺少磁盘映像2</h3><p>在重新创建不需要光盘的模板文件之后，我赶忙重新导入新的服务器上，但是，这回还是抛出了相同的异常，缺少磁盘映像，于是我和其他人的文件列表做了一下对比，发现我从 esxi 页面上面生成的模板文件只有 <code>.ovf</code>、<code>.vmdk</code> 和 <code>.mf</code> 文件共三个，少了明明已经勾选的 <code>.mvram</code>，于是无奈之下下载了专门做 ovf 模板的工具 <code>ovftool</code>，这个在官网就可以直接下载到。</p><p>解决方法：</p><p>使用 <code>ovftool</code> 生成相关模板，命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据虚拟机 testvm 生成的模板并下载到 /home/root/ovf 下</span></span><br><span class="line">ovftool vi://root@192.168.0.120/testvm /home/root/ovf</span><br></pre></td></tr></table></figure><h3 id="3-未知错误"><a href="#3-未知错误" class="headerlink" title="3. 未知错误"></a>3. 未知错误</h3><p>终于在集齐所有需要的文件之后，再次选择了上传，但是，还是没有成功，这回的报错更坑爹，直接说读取不到 key-value，到网上再搜了一整圈才发现，这个页面都有 BUG，官方推出了一个不建议商用的补丁来修复这个问题，补丁地址<a href="https://labs.vmware.com/flings/esxi-embedded-host-client" target="_blank" rel="noopener">https://labs.vmware.com/flings/esxi-embedded-host-client</a></p><p>解决方法：</p><p>先下载补丁文件，这是一个以 <code>vib</code> 作为后缀名的文件，将他上传到虚拟机的服务器上面(这一步需要现在 esxi 上开启 shell 和 ssh 服务)，然后通过 ssh 连接上 esxi，执行一下命令安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里我将它上传到了 /tmp 下</span></span><br><span class="line">esxcli software vib install -v /tmp/esxui-signed-12086396.vib</span><br><span class="line"><span class="comment"># 安装完成之后重启</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>等待重启完成之后，就可以上 web 页面导入 ovf 模板了，我到这里就解决了这个问题了。</p>]]></content>
    
    <summary type="html">
    
      事情的经过是这样的，我在一次出差时，厂家突然要收回借给我们的用来搭建测试环境的硬盘，无奈之下我只能将虚拟机转移到其他服务器上面，但是却遇到了一个极其操蛋的问题，那就生成的 `.ovf` 模板文件在导入到另一台服务器的时候报错了，提示缺少磁盘映像文件，我百度了一下，网上大部分的文章都是说缺少文件，但是并没有说缺的是什么文件，终于有个人突然提到是因为原虚拟机是由 iso 的，但是新的服务器上面并没有这个镜像，于是就报错了。
    
    </summary>
    
    
      <category term="虚拟机" scheme="http://reasuon.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="问题解决" scheme="http://reasuon.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
      <category term="esxi" scheme="http://reasuon.github.io/tags/esxi/"/>
    
      <category term="虚拟机" scheme="http://reasuon.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="备份" scheme="http://reasuon.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Java Font 跨平台中文乱码</title>
    <link href="http://reasuon.github.io/2019/05/08/%E8%AE%B0%E4%B8%80%E6%AC%A1Java%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>http://reasuon.github.io/2019/05/08/%E8%AE%B0%E4%B8%80%E6%AC%A1Java%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2019-05-08T15:20:57.000Z</published>
    <updated>2020-02-17T09:33:38.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Color color=<span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">Font font = <span class="keyword">new</span> Font(<span class="string">"msyh"</span>, Font.PLAIN, <span class="number">64</span>);</span><br></pre></td></tr></table></figure><h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>这套代码在 windows 平台上面跑的时候是完全没有问题的，但是在项目迁移到 Linux 的时候突然出现了中文乱码的问题。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>一开始猜想是在生成或使用字符串的时候，字符串的编码格式错误，但是断点监测全流程发现没有丝毫问题，是将文字写到图片上面的时候突然就乱码了，搜了一下发现绘图时乱码可能是字体不支持的问题，于是开始查看 Linux 的字体库。<br>以下命令皆为 CentOS7.2 的运行环境。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CentOS7 安装字体库</span></span><br><span class="line">yum install -y fontconfig</span><br><span class="line"><span class="comment"># 查看安装的字体</span></span><br><span class="line"><span class="built_in">fc</span>-list</span><br><span class="line"><span class="comment"># 这里查出了很多，所以筛选一下</span></span><br><span class="line"><span class="comment"># 查找中文字体</span></span><br><span class="line"><span class="built_in">fc</span>-list :lang=zh</span><br><span class="line"><span class="comment"># 发现一个都没有</span></span><br></pre></td></tr></table></figure><p>这里将 windows 平台的 <code>C:\windows\Fonts</code> 下的微软雅黑字体拷贝到 <code>/usr/share/fonts</code><br>就是下面这三个文件<br><code>msyh.ttc</code>、<code>msyhl.ttc</code>、<code>msyhbd.ttc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装字体并刷新缓存</span></span><br><span class="line"><span class="built_in">cd</span> /usr/share/fonts</span><br><span class="line">mkfontscale</span><br><span class="line">mkfontdir</span><br><span class="line"><span class="built_in">fc</span>-cache -fv</span><br></pre></td></tr></table></figure><p>运行结束正常输出汉字。</p>]]></content>
    
    <summary type="html">
    
      一开始猜想是在生成或使用字符串的时候，字符串的编码格式错误，但是断点监测全流程发现没有丝毫问题，是将文字写到图片上面的时候突然就乱码了，搜了一下发现绘图时乱码可能是字体不支持的问题，于是开始查看 Linux 的字体库。
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="问题解决" scheme="http://reasuon.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Java" scheme="http://reasuon.github.io/tags/Java/"/>
    
      <category term="中文乱码" scheme="http://reasuon.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>记 Debian 9 搭建 FreeSwitch</title>
    <link href="http://reasuon.github.io/2019/05/08/%E8%AE%B0Debian9%E6%90%AD%E5%BB%BAFreeSwitch/"/>
    <id>http://reasuon.github.io/2019/05/08/%E8%AE%B0Debian9%E6%90%AD%E5%BB%BAFreeSwitch/</id>
    <published>2019-05-08T15:20:57.000Z</published>
    <updated>2020-02-17T09:34:29.725Z</updated>
    
    <content type="html"><![CDATA[<p>根据官网进行 FreeSWITCH 服务器环境的安装与搭建，一下流程基本来自于官方教程，地址如下:<br><a href="https://freeswitch.org/confluence/display/FREESWITCH/Debian+9+Stretch" target="_blank" rel="noopener">https://freeswitch.org/confluence/display/FREESWITCH/Debian+9+Stretch</a>  </p><a id="more"></a><h2 id="便捷安装"><a href="#便捷安装" class="headerlink" title="便捷安装"></a>便捷安装</h2><p>在网络环境正常的情况下，基本上半小时内能够安装完成  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y gnupg2 wget</span><br><span class="line">wget -O - https://files.freeswitch.org/repo/deb/debian-release/fsstretch-archive-keyring.asc | apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://files.freeswitch.org/repo/deb/debian-release/ stretch main"</span> &gt; /etc/apt/sources.list.d/freeswitch.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb-src http://files.freeswitch.org/repo/deb/debian-release/ stretch main"</span> &gt;&gt; /etc/apt/sources.list.d/freeswitch.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># you may want to populate /etc/freeswitch at this point.</span></span><br><span class="line"><span class="comment"># if /etc/freeswitch does not exist, the standard vanilla configuration is deployed</span></span><br><span class="line">apt-get update &amp;&amp; apt-get install -y freeswitch-meta-all</span><br></pre></td></tr></table></figure><p>在使用 apt-get 安装完成之后，使用下面命令可以启动 FreeSWITCH 在终端上的客户端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs_cli -rRS</span><br></pre></td></tr></table></figure><p>在刚刚安装完就使用上面的指令，有可能与遇到启动失败的情况，大致内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@freeswitch:~<span class="comment"># fs_cli -rRS</span></span><br><span class="line">[ERROR] fs_cli.c:1688 main() Error Connecting []</span><br><span class="line">[INFO] fs_cli.c:1694 main() Retrying</span><br><span class="line">[ERROR] fs_cli.c:1688 main() Error Connecting []</span><br><span class="line">[INFO] fs_cli.c:1694 main() Retrying</span><br></pre></td></tr></table></figure><p>如果是这样说连接不上的话，有很大的可能是因为刚刚安装完成，FreeSWITCH 没有自启的原因，这时候输入<code>freeswitch -nc</code>这条指令在后台开启 FreeSWITCH，再输入<code>fs_cli -rRS</code>就可以了，如果还是失败也别着急关闭，有可能是因为 FreeSWITCH 还在启动中的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据官网进行 FreeSWITCH 服务器环境的安装与搭建，一下流程基本来自于官方教程，地址如下:&lt;br&gt;&lt;a href=&quot;https://freeswitch.org/confluence/display/FREESWITCH/Debian+9+Stretch&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://freeswitch.org/confluence/display/FREESWITCH/Debian+9+Stretch&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://reasuon.github.io/categories/Linux/"/>
    
    
      <category term="环境搭建" scheme="http://reasuon.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="Debian" scheme="http://reasuon.github.io/tags/Debian/"/>
    
      <category term="FreeSWITCH" scheme="http://reasuon.github.io/tags/FreeSWITCH/"/>
    
  </entry>
  
  <entry>
    <title>Typeperf 使用说明</title>
    <link href="http://reasuon.github.io/2019/04/24/Typeperf%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://reasuon.github.io/2019/04/24/Typeperf%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2019-04-24T07:14:10.000Z</published>
    <updated>2020-02-16T05:53:52.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Typeperf"><a href="#Typeperf" class="headerlink" title="Typeperf"></a>Typeperf</h2><p>Typeperf 是 cmd 中默认自带的一个记录系统资源使用情况的工具，它可以监控并记录指定程序或系统的运行情况。</p><h2 id="监控程序使用情况并记录到文本"><a href="#监控程序使用情况并记录到文本" class="headerlink" title="监控程序使用情况并记录到文本"></a>监控程序使用情况并记录到文本</h2><p>因为本人使用的是 cmder，所以命令的开头会有 <code>λ</code></p><h3 id="Typeperf-帮助"><a href="#Typeperf-帮助" class="headerlink" title="Typeperf 帮助"></a>Typeperf 帮助</h3><blockquote><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">λ  Typeperf -h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Microsoft ® TypePerf.exe (10.0.17763.1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">Typeperf 将性能数据写入命令窗口或日志文件。要停止 Typeperf，请按 CTRL+C.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">用法:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">C:\Windows\system32\typeperf.exe &#123; &lt;counter [counter ...]&gt; | -cf &lt;filename&gt; | -q [object] | -qx [object] &#125; [options]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">参数:</span></span><br><span class="line"> &lt;counter [counter ...]&gt;       要监视的性能计数器。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">选项:</span></span><br><span class="line"> -?                            显示跟上下文相关的帮助。</span><br><span class="line"> -f &lt;CSV|TSV|BIN|SQL&gt;          输出文件格式。默认值是 CSV。</span><br><span class="line"> -cf &lt;filename&gt;                含有监视的性能计数器的文件，一个计数器一行。</span><br><span class="line"> -si &lt;[[hh:]mm:]ss&gt;            示例间的时间。默认值是 1 秒。</span><br><span class="line"> -o &lt;filename&gt;                 输出文件或 SQL 数据库的路径。默认值为 STDOUT。</span><br><span class="line"> -q [object]                   列出已安装的计数器(无实例)。要列出某个对象的计数器，包括对象名，如 Processor。</span><br><span class="line"> -qx [object]                  列出已安装的计数器(带实例)。要列出某个对象的计数器，包括对象名，如 Processor。</span><br><span class="line"> -sc &lt;samples&gt;                 要收集的示例数量。默认值为，在 CTRL+C 之前都进行采样。</span><br><span class="line"> -config &lt;filename&gt;            含有命令选项的设置文件。</span><br><span class="line"> -s &lt;computer_name&gt;            在计数器路径中没有指定服务器的情况下要监视的服务器。</span><br><span class="line"> -y                            不用提示对所有问题都回答 yes。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">注意:</span></span><br><span class="line"> Counter 是性能计数器的全名，格式为</span><br><span class="line"> "\\&lt;Computer&gt;\&lt;Object&gt;(&lt;Instance&gt;)\&lt;Counter&gt;"；</span><br><span class="line"> 例如 "\\Server1\Processor(0)\% User Time"。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">示例:</span></span><br><span class="line"> typeperf "\Processor(_Total)\% Processor Time"</span><br><span class="line"> typeperf -cf counters.txt -si 5 -sc 50 -f TSV -o domain2.tsv</span><br><span class="line"> typeperf -qx PhysicalDisk -o counters.txt</span><br></pre></td></tr></table></figure></blockquote><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>目标: 监控 <code>idea64</code> 并记录成 csv 文件</p><ol><li><p>获取可用监视器</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">λ  Typeperf -qx Process | findstr "idea64"</span><br><span class="line">\Process(idea64)\% Processor Time</span><br><span class="line">\Process(idea64)\% User Time</span><br><span class="line">\Process(idea64)\% Privileged Time</span><br><span class="line">\Process(idea64)\Virtual Bytes Peak</span><br><span class="line">\Process(idea64)\Virtual Bytes</span><br><span class="line">\Process(idea64)\Page Faults/sec</span><br><span class="line">\Process(idea64)\Working Set Peak</span><br><span class="line">\Process(idea64)\Working Set</span><br><span class="line">\Process(idea64)\Page File Bytes Peak</span><br><span class="line">\Process(idea64)\Page File Bytes</span><br><span class="line">\Process(idea64)\Private Bytes</span><br><span class="line">\Process(idea64)\Thread Count</span><br><span class="line">\Process(idea64)\Priority Base</span><br><span class="line">\Process(idea64)\Elapsed Time</span><br><span class="line">\Process(idea64)\ID Process</span><br><span class="line">\Process(idea64)\Creating Process ID</span><br><span class="line">\Process(idea64)\Pool Paged Bytes</span><br><span class="line">\Process(idea64)\Pool Nonpaged Bytes</span><br><span class="line">\Process(idea64)\Handle Count</span><br><span class="line">\Process(idea64)\IO Read Operations/sec</span><br><span class="line">\Process(idea64)\IO Write Operations/sec</span><br><span class="line">\Process(idea64)\IO Data Operations/sec</span><br><span class="line">\Process(idea64)\IO Other Operations/sec</span><br><span class="line">\Process(idea64)\IO Read Bytes/sec</span><br><span class="line">\Process(idea64)\IO Write Bytes/sec</span><br><span class="line">\Process(idea64)\IO Data Bytes/sec</span><br><span class="line">\Process(idea64)\IO Other Bytes/sec</span><br><span class="line">\Process(idea64)\Working Set - Private</span><br></pre></td></tr></table></figure></li><li><p>监控程序的硬盘读写</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">λ  Typeperf -qx Process | findstr "idea64" | findstr "IO" &gt;&gt; counters.txt</span><br></pre></td></tr></table></figure><p>这时候会将一下数据写进 <code>counters.txt</code> 文本（该目录不存在该文件时会自动创建文件，但如果不存在父级目录则会创建失败，存在时会将数据写到文本的末尾）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\Process(idea64)\IO Read Operations&#x2F;sec</span><br><span class="line">\Process(idea64)\IO Write Operations&#x2F;sec</span><br><span class="line">\Process(idea64)\IO Data Operations&#x2F;sec</span><br><span class="line">\Process(idea64)\IO Other Operations&#x2F;sec</span><br><span class="line">\Process(idea64)\IO Read Bytes&#x2F;sec</span><br><span class="line">\Process(idea64)\IO Write Bytes&#x2F;sec</span><br><span class="line">\Process(idea64)\IO Data Bytes&#x2F;sec</span><br><span class="line">\Process(idea64)\IO Other Bytes&#x2F;sec</span><br></pre></td></tr></table></figure><p>注:<br>建议打开文本确认一下编码格式，我这里是 <code>UCS-2 LE BOM</code>，这种格式在我的环境中，后续的操作是无法识别文本内容的，建议改成 <code>utf-8</code>。<br>在我的环境中，如果不修改编码格式，就会报下面这个错误。  </p><blockquote><p>错误: 没有有效计数器。</p></blockquote></li><li><p>监控</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">λ  typeperf -f CSV -o test.csv -si 5 -sc 5 -cf .\counters.txt</span><br><span class="line"></span><br><span class="line">命令成功结束。</span><br></pre></td></tr></table></figure><p>等待命令完成，则 <code>test.csv</code> 中会存在需要的数据了。<br>内容大致如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;(PDH-CSV 4.0) (&quot;,&quot;\\COMPUTER-NAME\Process(idea64)\IO Read Operations&#x2F;sec&quot;,&quot;\\COMPUTER-NAME\Process(idea64)\IO Write Operations&#x2F;sec&quot;,&quot;\\COMPUTER-NAME\Process(idea64)\IO Data Operations&#x2F;sec&quot;,&quot;\\COMPUTER-NAME\Process(idea64)\IO Other Operations&#x2F;sec&quot;,&quot;\\COMPUTER-NAME\Process(idea64)\IO Read Bytes&#x2F;sec&quot;,&quot;\\COMPUTER-NAME\Process(idea64)\IO Write Bytes&#x2F;sec&quot;,&quot;\\COMPUTER-NAME\Process(idea64)\IO Data Bytes&#x2F;sec&quot;,&quot;\\COMPUTER-NAME\Process(idea64)\IO Other Bytes&#x2F;sec&quot;</span><br><span class="line">&quot;04&#x2F;24&#x2F;2019 14:58:16.286&quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;,&quot; &quot;</span><br><span class="line">&quot;04&#x2F;24&#x2F;2019 14:58:21.343&quot;,&quot;4.5609839747845013&quot;,&quot;0&quot;,&quot;4.5609839747845013&quot;,&quot;11.105004460344873&quot;,   &quot;362.69737782090664&quot;,&quot;0&quot;,&quot;362.69737782090664&quot;,&quot;177.68007136551796&quot;</span><br><span class="line">&quot;04&#x2F;24&#x2F;2019 14:58:26.368&quot;,&quot;5.1746771996557648&quot;,&quot;0&quot;,&quot;5.1746771996557648&quot;,&quot;12.5386409068582&quot;,   &quot;433.47872849424061&quot;,&quot;0&quot;,&quot;433.47872849424061&quot;,&quot;197.43383777148148&quot;</span><br><span class="line">&quot;04&#x2F;24&#x2F;2019 14:58:31.394&quot;,&quot;0.79587117949501573&quot;,&quot;0&quot;,&quot;0.79587117949501573&quot;,&quot;4.9741948718438485&quot;,   &quot;83.765441641850401&quot;,&quot;0&quot;,&quot;83.765441641850401&quot;,&quot;78.990214564880318&quot;</span><br><span class="line">&quot;04&#x2F;24&#x2F;2019 14:58:36.421&quot;,&quot;6.5637937200127858&quot;,&quot;0&quot;,&quot;6.5637937200127858&quot;,&quot;15.116615840029446&quot;,   &quot;530.47387428103332&quot;,&quot;0&quot;,&quot;530.47387428103332&quot;,&quot;241.86585344047114&quot;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      Typeperf 是 cmd 中默认自带的一个记录系统资源使用情况的工具，它可以监控并记录指定程序或系统的运行情况。
    
    </summary>
    
    
      <category term="工具" scheme="http://reasuon.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Typeperf" scheme="http://reasuon.github.io/tags/Typeperf/"/>
    
  </entry>
  
  <entry>
    <title>数组转List</title>
    <link href="http://reasuon.github.io/2019/04/23/%E6%95%B0%E7%BB%84%E8%BD%ACList/"/>
    <id>http://reasuon.github.io/2019/04/23/%E6%95%B0%E7%BB%84%E8%BD%ACList/</id>
    <published>2019-04-23T09:57:17.000Z</published>
    <updated>2020-02-19T02:53:38.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简易做法"><a href="#简易做法" class="headerlink" title="简易做法"></a>简易做法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String id = <span class="string">"a,b,c"</span>;</span><br><span class="line">List&lt;String&gt; ids = Arrays.asList(id.split(<span class="string">","</span>));</span><br></pre></td></tr></table></figure><p>在使用前，可以先尝试看一下 <code>Arrays.asList()</code> 的源码，这有助于防范一些比较明显的错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a fixed-size list backed by the specified array.  (Changes to</span></span><br><span class="line"><span class="comment"> * the returned list "write through" to the array.)  This method acts</span></span><br><span class="line"><span class="comment"> * as bridge between array-based and collection-based APIs, in</span></span><br><span class="line"><span class="comment"> * combination with &#123;<span class="doctag">@link</span> Collection#toArray&#125;.  The returned list is</span></span><br><span class="line"><span class="comment"> * serializable and implements &#123;<span class="doctag">@link</span> RandomAccess&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method also provides a convenient way to create a fixed-size</span></span><br><span class="line"><span class="comment"> * list initialized to contain several elements:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     List&amp;lt;String&amp;gt; stooges = Arrays.asList("Larry", "Moe", "Curly");</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the class of the objects in the array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array by which the list will be backed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list view of the specified array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，文档一开始就告诉我们，这个方法返回的是一个定长的数列。所以当我们添加或删除当中的元素时是会抛出异常的，所以我们需要将它进行转化一下<br>当然，如果并不需要添加或删除当中的元素，是可以不用转化的。</p><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>这里使用构造函数直接构造一个相同内容、不定长度的 <code>ArraysList</code>。<br>构造函数如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文档中提到，该构造函数用于生成包含指定元素的 <code>ArraysList</code> ，也就是说并没有长度限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String id = <span class="string">"a,b,c"</span>;</span><br><span class="line">List&lt;String&gt; ids = Arrays.asList(id.split(<span class="string">","</span>));</span><br><span class="line">List&lt;String&gt; ids2 = <span class="keyword">new</span> ArraysList&lt;&gt;(ids);</span><br></pre></td></tr></table></figure><p>简化一下就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String id = <span class="string">"a,b,c"</span>;</span><br><span class="line">List&lt;String&gt; ids = <span class="keyword">new</span> ArraysList&lt;&gt;(Arrays.asList(id.split(<span class="string">","</span>)));</span><br></pre></td></tr></table></figure><p>这样子就完成了一个数组转不定 <code>List</code> 的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简易做法&quot;&gt;&lt;a href=&quot;#简易做法&quot; class=&quot;headerlink&quot; title=&quot;简易做法&quot;&gt;&lt;/a&gt;简易做法&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://reasuon.github.io/tags/java/"/>
    
      <category term="数组" scheme="http://reasuon.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="List" scheme="http://reasuon.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 批量插入语句大小限制</title>
    <link href="http://reasuon.github.io/2019/02/19/MySQL%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/"/>
    <id>http://reasuon.github.io/2019/02/19/MySQL%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/</id>
    <published>2019-02-18T23:50:10.000Z</published>
    <updated>2020-02-18T07:24:50.947Z</updated>
    
    <content type="html"><![CDATA[<p>批量插入语句过多时报错</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>MySQL 数据库本身对执行的 SQL 语句的大小有限制，默认是 4M ，可以通过以下语句查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@max_allowed_packet;</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| @@max_allowed_packet |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">|              4194304 |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>通过以下语句可以修改最大执行语句的大小</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 修改为256M</span></span><br><span class="line">mysql&gt; SET GLOBAL max_allowed_packet=268435456;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>退出客户端重新登录，再输入语句查看最大值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@max_allowed_packet;</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">| @@max_allowed_packet |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">|            268435456 |</span><br><span class="line">+<span class="comment">----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;批量插入语句过多时报错&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://reasuon.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mysql" scheme="http://reasuon.github.io/tags/mysql/"/>
    
      <category term="配置" scheme="http://reasuon.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="问题解决" scheme="http://reasuon.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>Debian 终端颜色设置</title>
    <link href="http://reasuon.github.io/2019/01/24/Debian%E7%BB%88%E7%AB%AF%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE/"/>
    <id>http://reasuon.github.io/2019/01/24/Debian%E7%BB%88%E7%AB%AF%E9%A2%9C%E8%89%B2%E8%AE%BE%E7%BD%AE/</id>
    <published>2019-01-24T03:42:34.000Z</published>
    <updated>2020-02-17T09:55:51.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>PS1 是用来定义命令行提示符的参数，而我们每次登陆终端，使用命令时最前面的那一段就是 PS1，debian默认是没有颜色，且格式不美观的一串，例如: <code>[root@debian ~]#</code>，在进入多级文件夹之后，就会变成<code>[root@debian /xxx/xxx/xxx/xxx]#</code>，这会显得十分的难看。而这些问题，都可以通过修改 PS1 的参数来解决这个问题。  </p></blockquote><a id="more"></a><h2 id="颜色格式一览"><a href="#颜色格式一览" class="headerlink" title="颜色格式一览"></a>颜色格式一览</h2><blockquote><p>设置颜色的格式为：以 <code>[\e[F;Bm]</code> 开始，以 <code>\e[m</code> 结束。其中“F“为字体颜色，编号为30-37，“B”为背景颜色，编号为40-47。  </p><p><code>F B</code> 颜色<br><code>30 40</code> 黑色<br><code>31 41</code> 红色<br><code>32 42</code> 绿色<br><code>33 43</code> 黄色<br><code>34 44</code> 蓝色<br><code>35 45</code> 紫红色<br><code>36 46</code> 青蓝色<br><code>37 47</code> 白色  </p><p>特别代码意义  </p><p><code>0</code> OFF<br><code>1</code> 高亮显示<br><code>4</code> underline<br><code>5</code> 闪烁<br><code>7</code> 反白显示<br><code>8</code> 不可见  </p></blockquote><h2 id="PS1参数介绍"><a href="#PS1参数介绍" class="headerlink" title="PS1参数介绍"></a>PS1参数介绍</h2><blockquote><p><code>\d</code> ：代表日期，格式为weekday month date，例如：”Mon Aug 1”<br><code>\H</code> ：完整的主机名称<br><code>\h</code> ：仅取主机名中的第一个名字<br><code>\t</code> ：显示时间为24小时格式，如：HH：MM：SS<br><code>\T</code> ：显示时间为12小时格式<br><code>\A</code> ：显示时间为24小时格式：HH：MM<br><code>\u</code> ：当前用户的账号名称<br><code>\v</code> ：BASH的版本信息<br><code>\w</code> ：完整的工作目录名称<br><code>\W</code> ：利用basename取得工作目录名称，只显示最后一个目录名<br><code>\#</code> ：下达的第几个命令<br><code>\$</code> ：提示字符，如果是root用户，提示符为 # ，普通用户则为 $  </p><p>那么PS1=’[\u@\h \w]$ ‘的意思就是：[当前用户的账号名称@主机名的第一个名字 完整的工作目录名称]  </p></blockquote><h2 id="设置方式"><a href="#设置方式" class="headerlink" title="设置方式"></a>设置方式</h2><p>Debian的控制台设置是每个用户单独一份，存放在每个用户的<code>~/.bashrc</code>内，这里简单讲一下怎么设置。<br>我当前使用的 Debian 版本为 9.x ，root 用户默认的配置文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc: executed by bash(1) for non-login shells.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note: PS1 and umask are already set in /etc/profile. You should not</span></span><br><span class="line"><span class="comment"># need this unless you want different defaults for root.</span></span><br><span class="line"><span class="comment"># PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\h:\w\$ '</span></span><br><span class="line"><span class="comment"># umask 022</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You may uncomment the following lines if you want `ls' to be colorized:</span></span><br><span class="line"><span class="comment"># export LS_OPTIONS='--color=auto'</span></span><br><span class="line"><span class="comment"># eval "`dircolors`"</span></span><br><span class="line"><span class="comment"># alias ls='ls $LS_OPTIONS'</span></span><br><span class="line"><span class="comment"># alias ll='ls $LS_OPTIONS -l'</span></span><br><span class="line"><span class="comment"># alias l='ls $LS_OPTIONS -lA'</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Some more alias to avoid making mistakes:</span></span><br><span class="line"><span class="comment"># alias rm='rm -i'</span></span><br><span class="line"><span class="comment"># alias cp='cp -i'</span></span><br><span class="line"><span class="comment"># alias mv='mv -i'</span></span><br></pre></td></tr></table></figure><p>这个是默认的配置，其中，从第9行到第13行，是默认的文件系统的颜色，就是文件夹和文件的颜色，去掉注释就可以使用了，基本没有特别配置的需要。<br>这里也可以看到是有默认的 PS1 的配置的，虽然被注释掉了，这时候，我们只需要在下面加入我们自己的 PS1 配置就可以了，例如我的配置如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">'\[\e[37;40m\][\[\e[32;40m\]\u\[\e[37;40m\]@\h \[\e[35;40m\]\W\[\e[0m\]]\$ '</span></span><br></pre></td></tr></table></figure><p>因为我的终端是黑色为底色，所以我的所有背景都是黑色，白色终端的话，将<code>40m</code>更替为<code>47m</code>就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;PS1 是用来定义命令行提示符的参数，而我们每次登陆终端，使用命令时最前面的那一段就是 PS1，debian默认是没有颜色，且格式不美观的一串，例如: &lt;code&gt;[root@debian ~]#&lt;/code&gt;，在进入多级文件夹之后，就会变成&lt;code&gt;[root@debian /xxx/xxx/xxx/xxx]#&lt;/code&gt;，这会显得十分的难看。而这些问题，都可以通过修改 PS1 的参数来解决这个问题。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://reasuon.github.io/categories/Linux/"/>
    
    
      <category term="Debian" scheme="http://reasuon.github.io/tags/Debian/"/>
    
      <category term="终端" scheme="http://reasuon.github.io/tags/%E7%BB%88%E7%AB%AF/"/>
    
      <category term="个性化" scheme="http://reasuon.github.io/tags/%E4%B8%AA%E6%80%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Windows 上使用 Thrift</title>
    <link href="http://reasuon.github.io/2018/11/30/Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Thrift/"/>
    <id>http://reasuon.github.io/2018/11/30/Windows%E4%B8%8A%E4%BD%BF%E7%94%A8Thrift/</id>
    <published>2018-11-30T15:45:17.000Z</published>
    <updated>2020-02-18T07:39:18.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><strong>系统</strong> : Windows 7 64Bit</li><li><strong>语言</strong> : Java</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-工具生成代码"><a href="#1-工具生成代码" class="headerlink" title="1. 工具生成代码"></a>1. 工具生成代码</h3><p>虽然 Thrift 支持不同语言，但是不同语言的调用方式和定义的方式并不一样，所以官方准备了一个生成指定语言调用方式的工具，我们只需要使用该工具生成调用 Thrift 的接口，然后调用这个类就可以了。  </p><p>windows 平台想要调用该工具十分的简单，只需要在官方提供的地址下载一个可直接运行的二进制文件就可以了，不过需要注意的是，想要生成 Java 代码，还需要 Java 的运行环境才行（最后这不太确定，还没确认过）。<br>下载地址: <a href="http://www.apache.org/dyn/closer.cgi?path=/thrift/0.11.0/thrift-0.11.0.exe" target="_blank" rel="noopener">thrift-0.11.0</a><br>修改下载文件名为 <code>thrift.exe</code> ，在所在目录直接使用 cmd 调用即可。<br>命令如下:  </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:: 根据 Test.thrift 生成 Java 文件</span><br><span class="line">thrift -r -gen java Test.thrift</span><br></pre></td></tr></table></figure><h3 id="2-Spring-Boot-项目"><a href="#2-Spring-Boot-项目" class="headerlink" title="2. Spring Boot 项目"></a>2. Spring Boot 项目</h3><ol><li><p>导入 thrift 的相关包<br> 在 pox.xml 中引用包</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.thrift<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>libthrift<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写<code>.thrift</code>文件<br> 根据 Thrift 定义的语句编写接口文件 <code>Test.thrift</code> ，内容大致如下:</p> <figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义包位置</span></span><br><span class="line"><span class="keyword">namespace</span> java com.reasuon.thrift</span><br><span class="line"><span class="comment">//定义服务</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义接口</span></span><br><span class="line">    <span class="built_in">string</span> TestString(<span class="number">1</span>:<span class="built_in">string</span> param),</span><br><span class="line">    <span class="built_in">i32</span> TestInteger(<span class="number">1</span>:<span class="built_in">string</span> param)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 cmd 中使用 <code>thrift.exe</code> 生成 Java 代码，这个命令会生成一大串与 thrift 交互的 Java 代码，代码写的很简单清晰，感兴趣的可以看看，这里主要介绍生成的两个接口方法。</p></li><li><p>调用 <code>Test.java</code><br> 在 <code>Test.java</code> 的包下创建实现类 <code>TestServiceImpl.java</code>，内容如下:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">Test</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">TestString</span><span class="params">(String param)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Thrift 调用成功"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TestInteger</span><span class="params">(String param)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动 thrift<br> Thrift 的启动方式是启动一个专门的线程来实现功能，所以启动的方法比较随意，可以在 Spring 的启动方法 <code>XXXXApplication.java</code> 的 main 函数里面加入启动，也可以使用注解 <code>@Bean</code> ，将 thrift 的启动交由 Spring Boot 管理。<br> 这里展示使用最简单的方式，也就是在 <code>XXXXApplication.java</code> 的 main 中加入启动</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"服务端开启...."</span>);</span><br><span class="line">            TProcessor tprocessor = <span class="keyword">new</span> Test.Processor&lt;Test.Iface&gt;(<span class="keyword">new</span> TestImpl());</span><br><span class="line">            <span class="comment">// 简单的单线程服务模型</span></span><br><span class="line">            TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(<span class="number">8056</span>);</span><br><span class="line">            TServer.Args tArgs = <span class="keyword">new</span> TServer.Args(serverTransport);</span><br><span class="line">            tArgs.processor(tprocessor);</span><br><span class="line">            tArgs.protocolFactory(<span class="keyword">new</span> TBinaryProtocol.Factory());</span><br><span class="line">            TServer server = <span class="keyword">new</span> TSimpleServer(tArgs);</span><br><span class="line">            server.serve();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TTransportException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试<br> 编写一个简单的客户端对服务端做一个简单的测试，代码如下:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThriftTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        TTransport transport = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            transport = <span class="keyword">new</span> TSocket(<span class="string">"localhost"</span>, <span class="number">8056</span>, <span class="number">30000</span>);</span><br><span class="line">            <span class="comment">// 协议要和服务端一致</span></span><br><span class="line">            TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">            Test.Client client = <span class="keyword">new</span> Test.Client(protocol);</span><br><span class="line">            transport.open();</span><br><span class="line">            String result = client.TestString(<span class="string">"xxxx"</span>);</span><br><span class="line">            Integer i = client.TestInteger(<span class="string">"xxxx"</span>);</span><br><span class="line">            System.out.println(result + <span class="string">"--&gt;"</span> +  i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TTransportException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != transport) &#123;</span><br><span class="line">                transport.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出的内容如下:</p> <figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thrift 调用成功--&gt;1</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      虽然 Thrift 支持不同语言，但是不同语言的调用方式和定义的方式并不一样，所以官方准备了一个生成指定语言调用方式的工具，我们只需要使用该工具生成调用 Thrift 的接口，然后调用这个类就可以了。
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="windows" scheme="http://reasuon.github.io/tags/windows/"/>
    
      <category term="rpc" scheme="http://reasuon.github.io/tags/rpc/"/>
    
      <category term="thrift" scheme="http://reasuon.github.io/tags/thrift/"/>
    
  </entry>
  
  <entry>
    <title>记一次Java项目jdk版本错误</title>
    <link href="http://reasuon.github.io/2018/11/17/%E8%AE%B0%E4%B8%80%E6%AC%A1Java%E9%A1%B9%E7%9B%AEjdk%E7%89%88%E6%9C%AC%E9%94%99%E8%AF%AF/"/>
    <id>http://reasuon.github.io/2018/11/17/%E8%AE%B0%E4%B8%80%E6%AC%A1Java%E9%A1%B9%E7%9B%AEjdk%E7%89%88%E6%9C%AC%E9%94%99%E8%AF%AF/</id>
    <published>2018-11-17T04:44:16.000Z</published>
    <updated>2020-02-17T09:17:47.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在VSCode创建项目并导入<code>.java</code>文件后，报语句支持的最低版本为JDK1.8，但是在配置文件中指定的<code>java.home</code>为<code>jdk1.8.0121</code>，在pom.xml指定maven的jdk的版本号之后仍旧无法解决问题，也尝试在<code>.\.settings\org.eclipse.jdt.core.prefs</code>文件中将指定的1.7更改为1.8，仍旧没有解决问题。</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在全局搜索1.7之后突然发现在<code>.\.classpath</code>文件下有如下语句：  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">classpathentry</span> <span class="attr">kind</span>=<span class="string">"con"</span> <span class="attr">path</span>=<span class="string">"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.7"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将该语句尾部的<code>JavaSE-1.7</code>修改为<code>JavaSE1.8</code>后成功解决问题。</p><h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>解决方案中所展示的语句是检测语句合法性的jdk的规则版本。</p><h2 id="证实猜想"><a href="#证实猜想" class="headerlink" title="证实猜想"></a>证实猜想</h2><p>经过查阅后发现，<code>.classpath</code>文件本是<code>Eclipse</code>这个IDE特有的一个文件，用来指定配置和指定整个项目工程的环境，其中，猜想中提到的语句是指定了一个外部的插件，作用是在编译代码之前检测代码的合法性，而在VSCode中，Java代码的插件也是采用了这种机制，所以需要在<code>.classpath</code>中指定检测代码合法性的jdk的版本。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;在VSCode创建项目并导入&lt;code&gt;.java&lt;/code&gt;文件后，报语句支持的最低版本为JDK1.8，但是在配置文件中指定的&lt;code&gt;java.home&lt;/code&gt;为&lt;code&gt;jdk1.8.0121&lt;/code&gt;，在pom.xml指定maven的jdk的版本号之后仍旧无法解决问题，也尝试在&lt;code&gt;.\.settings\org.eclipse.jdt.core.prefs&lt;/code&gt;文件中将指定的1.7更改为1.8，仍旧没有解决问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="问题解决" scheme="http://reasuon.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
      <category term="Java" scheme="http://reasuon.github.io/tags/Java/"/>
    
      <category term="jdk" scheme="http://reasuon.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>centos7搭建netdata的简单记录</title>
    <link href="http://reasuon.github.io/2018/11/13/CentOS7%E6%90%AD%E5%BB%BAnetdata%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://reasuon.github.io/2018/11/13/CentOS7%E6%90%AD%E5%BB%BAnetdata%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</id>
    <published>2018-11-13T15:53:00.000Z</published>
    <updated>2020-02-18T07:11:54.494Z</updated>
    
    <content type="html"><![CDATA[<p>这份文档是根据netdata的wiki逐步完成的一份记录，如果出现命令错误或者过时等问题，可以移至netdata的wiki，根据指导完成操作。<br><a href="https://github.com/netdata/netdata/wiki/Installation" target="_blank" rel="noopener">netdata wiki - install</a></p><!-- mode --><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><ul><li><p>一台联网的centos7主机</p></li><li><p>安装环境</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install autoconf automake curl gcc git libmnl-devel libuuid-devel lm_sensors make MySQL-python nc pkgconfig python python-psycopg2 PyYAML zlib-devel -y</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-下载项目"><a href="#2-下载项目" class="headerlink" title="2. 下载项目"></a>2. 下载项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用git将含安装脚本的项目下至本地  </span></span><br><span class="line"><span class="comment"># git clone https://github.com/netdata/netdata.git --depth=1</span></span><br><span class="line"><span class="comment"># 使用该命令之后会下载一个 netdata 文件夹</span></span><br><span class="line"><span class="comment"># 所以请确保当前的路径没有名为 netdata 的文件或文件夹</span></span><br><span class="line"><span class="comment"># 或者使用git命令指向指定的文件夹。  </span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/netdata/netdata.git --depth=1 ~/netdata/</span><br><span class="line"><span class="comment"># 需要注意的是，如果自己指定了目录，则不会生成名为netdata的文件夹，所以要自己指定一个文件夹。</span></span><br></pre></td></tr></table></figure><h2 id="3-安装项目"><a href="#3-安装项目" class="headerlink" title="3.安装项目"></a>3.安装项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为是自带了安装脚本，所以直接执行脚本就可以完成安装</span></span><br><span class="line"><span class="comment"># 不要需要注意的是，默认的安装路径稍微有点坑，所以需要在安装的时候指定安装路径</span></span><br><span class="line"><span class="comment"># 这里假定我的git clone位置为`~/netdata/`  </span></span><br><span class="line"><span class="comment"># 这里指定安装到/usr/local，因为脚本，安装路径会变成/usr/local/netdata/</span></span><br><span class="line"><span class="comment"># 安装期间也会输出安装路径让用户进行确认，确认无误后回车即可继续</span></span><br><span class="line"><span class="comment"># eg:Press ENTER to build and install netdata to '/usr/local/netdata' &gt; </span></span><br><span class="line">~/netdata/netdata-installer.sh --install /usr/<span class="built_in">local</span></span><br><span class="line"><span class="comment"># 如果不想在安装完成之后自启动，可以增加 --dont-start-it</span></span><br><span class="line"><span class="comment"># ~/netdata/netdata-installer.sh --install /usr/local --dont-start-it</span></span><br></pre></td></tr></table></figure><h2 id="4-设置为服务并自启动"><a href="#4-设置为服务并自启动" class="headerlink" title="4.设置为服务并自启动"></a>4.设置为服务并自启动</h2><p>如果每次重新启动服务器之后都需要进入<code>/usr/sbin</code>开启<code>netdata</code>的话，明显和我们的使用习惯不大相同，所以我们需要将他注册成服务，并设置为开机自启动模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先粗暴的关闭netdata</span></span><br><span class="line">killall netdata</span><br><span class="line"><span class="comment"># 拷贝服务文件</span></span><br><span class="line">cp ~/netdata/system/netdata.service /etc/systemd/system/</span><br><span class="line"><span class="comment"># 重新加载服务列表</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 允许开启netdata服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> netdata</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start netdata</span><br><span class="line"><span class="comment"># 复制自启动脚本</span></span><br><span class="line">cp ~/netdata/system/netdata-init<span class="_">-d</span> /etc/init.d/netdata</span><br><span class="line"><span class="comment"># 增加脚本可执行权限</span></span><br><span class="line">chmod +x /etc/init.d/netdata</span><br><span class="line"><span class="comment"># 设置服务自启</span></span><br><span class="line">chkconfig --add netdata</span><br></pre></td></tr></table></figure><h2 id="5-测试访问"><a href="#5-测试访问" class="headerlink" title="5.测试访问"></a>5.测试访问</h2><p>默认的端口是<code>19999</code>，在浏览器中输入<code>http://[centos ip]:19999</code>即可访问，如果出现服务器阻止访问，则需要在防火墙开启19999的端口的tcp协议，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 永久开放端口19999</span></span><br><span class="line">firewall-cmd --zone=public --add-port=19999/tcp --permanent</span><br><span class="line"><span class="comment"># 重新装载防火墙规则</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="6-增加权限认证"><a href="#6-增加权限认证" class="headerlink" title="6.增加权限认证"></a>6.增加权限认证</h2><p>如果是带公网ip的服务器，且需要将该页面放在公网上方便访问，则需要对访问的权限做验证，<br><code>netdata</code>的设计理念是分布式的服务器监控，那么每个服务器都有自己的子页面，那么每个页面都有一个权限验证是不可能的，<br>加之因为登陆信息不共通，那么每个页面都要重复登陆，这不符合常理，<br>所以官方提倡我们外部使用其他服务器对<code>netdata</code>的访问做反向代理并做权限验证。<br>这里我推荐使用使用nginx做反向代理和权限验证<br>一是nginx可以只用配置文件就达到目的，<br>完全不用管源码，上手门槛低，且功能强大；<br>二是因为nginx性能损耗低，功能强大，毕竟一个性能监控没必要浪费过多的性能；<br>三是扩展性良好，直接在配置文件加上另一个服务器的ip和端口就行了，方便维护；</p><p>这里呢，我们采用源码安装nginx<br>首先，在github上面下载最新的源代码，我这里是下载了<a href="http://nginx.org/download/nginx-1.15.5.tar.gz" target="_blank" rel="noopener">nginx-1.15.5</a> 的版本。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把压缩包下载到~</span></span><br><span class="line">wget -P ~ http://nginx.org/download/nginx-1.15.5.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf nginx-1.15.5.tar.gz</span><br><span class="line"><span class="comment"># 安装编译所需环境</span></span><br><span class="line">yum -y install openssl openssl-devel</span><br><span class="line"><span class="comment"># 编译并指定安装到/usr/local/nginx</span></span><br><span class="line"><span class="comment"># 这一步并不会安装</span></span><br><span class="line">./nginx-1.15.5/.configure --prefix=/usr/<span class="built_in">local</span>/nginx</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vi /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>修改代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 以上无关省略...</span><br><span class="line"></span><br><span class="line">    # netdata服务器位置</span><br><span class="line">    # 因为我都是放在同一台服务器，所以直接用localhost</span><br><span class="line">    # 如果需要引入外部的服务器，需要在服务器上开放19999端口</span><br><span class="line">    # 并限制只有nginx服务器的ip才能访问</span><br><span class="line">    upstream netdataServer &#123;</span><br><span class="line">        server localhost:19999;</span><br><span class="line">        keepalive 64;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server&#123;</span><br><span class="line">        # nginx端口自己定，建议不要使用80和19999</span><br><span class="line">        listen       8099;</span><br><span class="line">           server_name  localhost;</span><br><span class="line"></span><br><span class="line">        # 权限验证部分，指定身份验证文件，后面会提到如何创建</span><br><span class="line">        auth_basic &quot;Restricted Access&quot;;</span><br><span class="line">        auth_basic_user_file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;htpasswd.users;</span><br><span class="line"></span><br><span class="line">        #这里如果有多个服务器可以用?&lt;xxx&gt;代指不同服务器</span><br><span class="line">        location ~ &#x2F;netdata&#x2F;(?&lt;ndpath&gt;.*) &#123;</span><br><span class="line">            proxy_set_header X-Forwarded-Host $host;</span><br><span class="line">            proxy_set_header X-Forwarded-Server $host;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_pass_request_headers on;</span><br><span class="line">            proxy_set_header Connection &quot;keep-alive&quot;;</span><br><span class="line">            proxy_store off;</span><br><span class="line">            # 这里也要改为$xxx</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;netdataServer&#x2F;$ndpath$is_args$args;</span><br><span class="line">            gzip on;</span><br><span class="line">            gzip_proxied any;</span><br><span class="line">            gzip_types *;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#以下无关省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完还没结束，需要开放端口和创建身份验证的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开放端口，这里改为你自己的nginx监听的端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8099/tcp --permanent</span><br><span class="line"><span class="comment"># 下载工具</span></span><br><span class="line">yum install -y httpd-tools</span><br><span class="line"><span class="comment"># 生成身份验证文件</span></span><br><span class="line">htpasswd -bc /usr/<span class="built_in">local</span>/nginx/conf/htpasswd.users username password</span><br><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -c /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这份文档是根据netdata的wiki逐步完成的一份记录，如果出现命令错误或者过时等问题，可以移至netdata的wiki，根据指导完成操作。&lt;br&gt;&lt;a href=&quot;https://github.com/netdata/netdata/wiki/Installation&quot;
      
    
    </summary>
    
    
      <category term="工具" scheme="http://reasuon.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="centos7" scheme="http://reasuon.github.io/tags/centos7/"/>
    
      <category term="netdata" scheme="http://reasuon.github.io/tags/netdata/"/>
    
      <category term="环境搭建" scheme="http://reasuon.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>关于notepad++没有插件管理器的解决方案</title>
    <link href="http://reasuon.github.io/2018/11/08/%E5%85%B3%E4%BA%8Enotepad++%E6%B2%A1%E6%9C%89%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://reasuon.github.io/2018/11/08/%E5%85%B3%E4%BA%8Enotepad++%E6%B2%A1%E6%9C%89%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2018-11-08T15:43:07.000Z</published>
    <updated>2020-02-18T07:37:04.796Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>notepad++</code>中，插件管理器(Plugin Manager)是一个十分实用的功能，不过出于某种原因，notepad++在最新的版本中将此功能去除了，并且从这个劲头来看，之后的版本中也不会再提供该功能(莫非是使用的人太少了？)<br>不过不管是出于什么原因，该功能对程序员来说还是十分实用的。<br>虽然notepad++最新版本已经不包含插件管理器，但是并不代表它不支持，仅仅只是将其从默认安装变成了需要我们手动下载和安装。  </p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方案很简单，但还是分为简单的方案和较为不简单的方案</p><ol><li>简单的方案(虽然说是一个简单的方案，其实算得上是一个偷工减料的方案)<ul><li>下载7.50(不包括7.50)之前的版本。</li><li>因为在7.50版本开始，官方将notepad++32位的插件管理器去掉了。所以只要下载之前的版本就可以了。</li></ul></li><li>较为不简单的方案<ul><li>下载最新版本的notepad++32位，并安装最新的插件管理器。</li><li>最新的插件管理器可以在官网上找到下载链接，找不到的话可以直接百度。这种方法比下载之前版本的好处就是之前的BUG或者一些不足都做了修改和补足，不好的就是容易出现新的BUG，甚至是出现暂时找不到解决方案的BUG。</li></ul></li></ol><p>注意事项<br><strong>不管是64位的系统还是32位的系统，我们都建议使用32位的notepad++，因为插件的支持会好上很多，64位有较多的插件会出现不兼容的情况</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;notepad++&lt;/code&gt;中，插件管理器(Plugin Manager)是一个十分实用的功能，不过出于某种原因，notepad++在最新的版本中将此功能去除了，并且从这个劲头来看，之后的版本中也不会再提供该功能(莫非是使用的人太少了？)&lt;br&gt;不过不管是出于什么原因，该功能对程序员来说还是十分实用的。&lt;br&gt;虽然notepad++最新版本已经不包含插件管理器，但是并不代表它不支持，仅仅只是将其从默认安装变成了需要我们手动下载和安装。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://reasuon.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="问题解决" scheme="http://reasuon.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
      <category term="notepad++" scheme="http://reasuon.github.io/tags/notepad/"/>
    
      <category term="插件管理" scheme="http://reasuon.github.io/tags/%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL5.7版本新特性</title>
    <link href="http://reasuon.github.io/2018/11/08/MySQL5_7%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://reasuon.github.io/2018/11/08/MySQL5_7%E7%89%88%E6%9C%AC%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2018-11-08T03:43:07.000Z</published>
    <updated>2020-02-18T07:01:04.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语句兼容问题"><a href="#语句兼容问题" class="headerlink" title="语句兼容问题"></a>语句兼容问题</h2><p>mysql5.7默认开启<code>only_full_group_by</code>,为了兼容以前的sql语句,需要将<code>mysql.ini</code>(<code>my.ini</code>)中<code>sql_mode的only_full_group_by</code>删除。<br>不推荐直接在数据库中修改配置文件缓存，因为再重启数据库后悔重新加载，则需要重新删除。<br>如果安装在C盘的： 我们要进入 C:\ProgramData\MySQL\MySQL Server 5.7 此目录即可看到my.ini</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>mysql.ini(my.ini在免安装版本中由自己创建)<br>windows 7环境下在安装版本中默认为<code>C:\ProgramData\MySQL\MySQL Server 5.7</code>目录下<br><code>mysql.ini</code>基本内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">port&#x3D;3306</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># 设置为自己MYSQL的安装目录</span><br><span class="line">basedir&#x3D;C:\Program Files (x86)\MySQL\mysql-5.7.20-win32</span><br><span class="line"># 设置为MYSQL的数据目录</span><br><span class="line">datadir&#x3D;C:\Program Files (x86)\MySQL\mysql-5.7.20-win32\data</span><br><span class="line">port&#x3D;3306</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">sql_mode&#x3D;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">#开启查询缓存</span><br><span class="line">explicit_defaults_for_timestamp&#x3D;true</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><h2 id="配置文件无效方法"><a href="#配置文件无效方法" class="headerlink" title="配置文件无效方法"></a>配置文件无效方法</h2><p>Mysql会默认装载my.ini，但是需要该文件在指定的文件夹下<br>使用<code>mysqld --verbose -help</code>命令可以查看加载顺序，如若无法加载到任何配置文件是，会返回提示<br>此时将需要加载的my.ini放在指定文件夹下，重新执行此命令，即可将此配置文件加入配置加载项中</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语句兼容问题&quot;&gt;&lt;a href=&quot;#语句兼容问题&quot; class=&quot;headerlink&quot; title=&quot;语句兼容问题&quot;&gt;&lt;/a&gt;语句兼容问题&lt;/h2&gt;&lt;p&gt;mysql5.7默认开启&lt;code&gt;only_full_group_by&lt;/code&gt;,为了兼容以前的sql
      
    
    </summary>
    
    
      <category term="工具" scheme="http://reasuon.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mysql" scheme="http://reasuon.github.io/tags/mysql/"/>
    
      <category term="新特性" scheme="http://reasuon.github.io/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java连接Access数据库</title>
    <link href="http://reasuon.github.io/2018/11/08/Java%E8%BF%9E%E6%8E%A5Access%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://reasuon.github.io/2018/11/08/Java%E8%BF%9E%E6%8E%A5Access%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2018-11-08T03:43:07.000Z</published>
    <updated>2020-02-19T02:57:46.576Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据sql语句将查询Access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql 查询Access数据库的语句</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accessUrl Access数据库地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> List&lt;Map&gt;</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment">public List&lt;Map&lt;String, Object&gt;&gt; selectAccess(String sql, String accessUrl) &#123;</span></span><br><span class="line"><span class="comment">    List&lt;Map&lt;String, Object&gt;&gt; mapList = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">    Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">    /* 中文乱码处理 */</span></span><br><span class="line">    prop.put(<span class="string">"charSet"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line">    prop.put(<span class="string">"user"</span>, <span class="string">""</span>);</span><br><span class="line">    prop.put(<span class="string">"password"</span>, <span class="string">""</span>);</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 加载驱动&amp;建立连接 */</span></span><br><span class="line">        Class.forName(<span class="string">"net.ucanaccess.jdbc.UcanaccessDriver"</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:ucanaccess://"</span> + accessUrl, <span class="string">"账号"</span>, <span class="string">"密码"</span>);</span><br><span class="line">        stmt = conn.createStatement();</span><br><span class="line">        rs = stmt.executeQuery(sql);</span><br><span class="line">        ResultSetMetaData data = rs.getMetaData();</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= data.getColumnCount(); i++) &#123;</span><br><span class="line">                <span class="comment">/* 列名 */</span></span><br><span class="line">                String columnName = data.getColumnName(i);</span><br><span class="line">                <span class="comment">/* 值 */</span></span><br><span class="line">                String columnValue = rs.getString(i);</span><br><span class="line">                map.put(columnName, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">        mapList.add(map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 关闭连接 */</span></span><br><span class="line">        conn.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mapList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>Access数据库时间的格式为<code>m/d/yyyy</code>，即使显示出来的数据为<code>yyyy/m/d</code></li><li><code>JAVA 7</code>以及之前的版本自带连接数据库的jdbc，但是之后的版本jdbc被移除，所以使用<code>JAVA 8</code>以及更高版本连接Access数据库时需要导入jar包</li><li><code>Access_JDBC30.jar</code>是<strong>付费使用</strong>，不付费会有连接次数和获取的最大记录条数限制（50次连接，1000最大记录）</li><li>连接Access数据库尽量使用<code>UCanAccess.jar</code>，目前没有任何限制</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://reasuon.github.io/tags/java/"/>
    
      <category term="access" scheme="http://reasuon.github.io/tags/access/"/>
    
      <category term="数据库连接" scheme="http://reasuon.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="jdbc" scheme="http://reasuon.github.io/tags/jdbc/"/>
    
  </entry>
  
  <entry>
    <title>Java项目使用EasyPoi</title>
    <link href="http://reasuon.github.io/2018/11/08/Java%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8EasyPoi/"/>
    <id>http://reasuon.github.io/2018/11/08/Java%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8EasyPoi/</id>
    <published>2018-11-08T03:43:07.000Z</published>
    <updated>2020-02-17T08:34:27.625Z</updated>
    
    <content type="html"><![CDATA[<p>EasyPoi目前是通过适配实体类和excel表来完成对excel的上传、生成和格式化。<br>而主要是根据文件流或字节（符）流的方式装载和生成excel表。  </p><a id="more"></a><h2 id="EasyPoi的jar包"><a href="#EasyPoi的jar包" class="headerlink" title="EasyPoi的jar包"></a>EasyPoi的jar包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jeecg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-base<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jeecg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jeecg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easypoi-annotation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="范例实体类"><a href="#范例实体类" class="headerlink" title="范例实体类"></a>范例实体类</h2><p>因为EasyPoi对excel的基本操作主要是通过实体类来完成，所以在最前面我把底下范例中的实体类先贴出来，方便查阅。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * excel表实体类</span></span><br><span class="line"><span class="comment"> * excel的实体类主要对应1行数据，就是说excel每行都需要一个实体类装载当前行的数据.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@ExcelTarget</span>(<span class="string">"examExcel"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamExcel</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* name 为当前的名称,orderNum 为列的列数 */</span></span><br><span class="line">    <span class="meta">@Excel</span>(name = <span class="string">"教室编号"</span>, orderNum = <span class="string">"1"</span>)</span><br><span class="line">    <span class="keyword">private</span> String classroomCode;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Excel</span>(name = <span class="string">"考试地点"</span>, orderNum = <span class="string">"2"</span>)</span><br><span class="line">    <span class="keyword">private</span> String examLocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Excel</span>(name = <span class="string">"考场名称"</span>, orderNum = <span class="string">"3"</span>)</span><br><span class="line">    <span class="keyword">private</span> String examRoom;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Excel</span>(name = <span class="string">"场次"</span>, orderNum = <span class="string">"4"</span>)</span><br><span class="line">    <span class="keyword">private</span> String examRound;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Excel</span>(name = <span class="string">"考试日期"</span>, orderNum = <span class="string">"5"</span>)</span><br><span class="line">    <span class="keyword">private</span> String examDate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Excel</span>(name = <span class="string">"考试时间"</span>, orderNum = <span class="string">"6"</span>)</span><br><span class="line">    <span class="keyword">private</span> String examTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Excel</span>(name = <span class="string">"考试课程"</span>, orderNum = <span class="string">"7"</span>)</span><br><span class="line">    <span class="keyword">private</span> String examCourse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** get方法和set的方法这里篇幅问题就略过不贴出来了 */</span></span><br></pre></td></tr></table></figure><h2 id="上传excel的实现"><a href="#上传excel的实现" class="headerlink" title="上传excel的实现"></a>上传excel的实现</h2><p>文件流实现excel的上传  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传excel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">importExamInfo</span><span class="params">(MultipartFile excel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//装载数据</span></span><br><span class="line">    List&lt;ExamExcel&gt; examExcelList = ExcelImportUtil.importExcel(inputStream,ExamExcel<span class="class">.<span class="keyword">class</span>, <span class="title">params</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成excel并下载的实现"><a href="#生成excel并下载的实现" class="headerlink" title="生成excel并下载的实现"></a>生成excel并下载的实现</h2><p><code>getExamList(examId)</code>是访问数据库获取表数据的方法，这里就不贴出来了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选中examId后，根据数据库获取excel表中应该有的数据，并通过实体类生成表，并通过response直接返回给用户.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params</span> examId 实体类id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params</span> response 用户的请求，这里是用来返回excel文件的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportExamExcel</span><span class="params">(<span class="keyword">long</span> examId, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 告诉浏览器用什么软件可以打开此文件</span></span><br><span class="line">    response.setHeader(<span class="string">"content-Type"</span>, <span class="string">"application/vnd.ms-excel"</span>);</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="comment">// 这里需要指定一下文件输出是文件名的编码，否则在编码格式不同或不支持的情况下可能造成乱码</span></span><br><span class="line">    response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + URLEncoder.encode(<span class="string">"exam表"</span>,<span class="string">"UTF-8"</span>) + <span class="string">".xls"</span>);</span><br><span class="line">    List&lt;ExamExcel&gt; list = getExamExcelByList(getExamList(examId));</span><br><span class="line">    Workbook workbook = ExcelExportUtil.exportExcel(<span class="keyword">new</span> ExportParams(), ExamExcel<span class="class">.<span class="keyword">class</span>, <span class="title">list</span>)</span>;</span><br><span class="line">    workbook.write(response.getOutputStream());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List转ExamExcel</span></span><br><span class="line"><span class="comment"> * 这里也需要先提一下，这个方法不是必备的，只是当时我那个项目是将数据库的数据取出时是以List&lt;Map&lt;String, Object&gt;&gt;的方式取出的，所以在这里需要转换为List&lt;实体类&gt;.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ExamExcel&gt; <span class="title">getExamExcelByList</span><span class="params">(List&lt;Map&lt;String, Object&gt;&gt; examList)</span> </span>&#123;</span><br><span class="line">    List&lt;ExamExcel&gt; examExcelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map&lt;String, Object&gt; examMap : examList) &#123;</span><br><span class="line">        ExamExcel examExcel = <span class="keyword">new</span> ExamExcel(examMap);</span><br><span class="line">        examExcelList.add(examExcel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> examExcelList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对excel的格式化处理"><a href="#对excel的格式化处理" class="headerlink" title="对excel的格式化处理"></a>对excel的格式化处理</h2><p>要对excel进行美化的话这一步十分重要，但是因为EasyPoi将对excel的数据的操作进行了封装，所以我们可以在实体类中直接对数据进行格式化，而不用自己写方法。<br>当前版本对实体类的操作主要是通过注解来操作，例如<code>@Excel</code>里面的<code>name</code>代表列名，<code>orderNum</code>代表列数一样，所有对数据的格式化基本都可以通过注解来完成。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EasyPoi目前是通过适配实体类和excel表来完成对excel的上传、生成和格式化。&lt;br&gt;而主要是根据文件流或字节（符）流的方式装载和生成excel表。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://reasuon.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="http://reasuon.github.io/tags/java/"/>
    
      <category term="easypoi" scheme="http://reasuon.github.io/tags/easypoi/"/>
    
  </entry>
  
</feed>
